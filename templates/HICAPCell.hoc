begintemplate HICAPCell

public connect2target, subsets, is_art, is_connected
public all, soma, dend, basal, apical, allsomadend, ais, hillock, axon, allaxon
public somaidx, dendidx, basalidx, apicalidx, axonidx
public xx, yy, zz, position
public syns, layers
public syn_stim, syntest

create sections[1]

objref all, soma, dend, basal, apical, ais, allsomadend, hillock, axon, allaxon
objref apicalidx, dendidx, basalidx, somaidx, axonidx, aisidx, hilidx
objref syns, layers

gid = -1

ndends   = -1
ndendsec = -1
nDends   = -1

proc assert() { local test strdef errmsg
    
    test = $1
    errmsg = $s2
    
    if (!test) {
        execerror ("Assertion failed: ", errmsg)
    }
}

proc init() {
    
    
    apicalidx = new Vector()
    basalidx = new Vector()
    dendidx = new Vector()
    somaidx = new Vector()
    axonidx = new Vector()
    aisidx = new Vector()
    hilidx = new Vector()
    layers = new List()
    syns = new List()
    
    gid = $1
    
    if (numarg() > 2) {
        topol_from_python($o3,$o5,$o6,$o11)
        shape_from_python($o3,$o7,$o8,$o9,$o10)
        layers_from_python($o3,$o4)
    } else {
        ndends   = 4
        ndendsec = 4
        create sections[ndends*ndendsec+1]
        
        somaidx.append(0)
        i=0
        for j=0, ndendsec-1 { 
            basalidx.append(1+i*ndendsec + j)
        }
        i=1
        for j=0, ndendsec-1 { 
            basalidx.append(1+i*ndendsec + j)
        }
        i=2
        for j=0, ndendsec-1 { 
            apicalidx.append(1+i*ndendsec + j)
        }
        i=3
        for j=0, ndendsec-1 { 
            apicalidx.append(1+i*ndendsec + j)
        }
        
        topol(ndends,ndendsec)
        geom()
    }
    subsets()
    geom_nseg()
    biophys()
}

proc subsets() { local i, ndends, ndendsec
    
    all = new SectionList()
    sections[0] all.append()
    for i=0, nSoma+nDends-1 { 
        sections[i+1] all.append() 
    }
    
    soma = new SectionList()
    sections[0] soma.append()
    
    dend = new SectionList()
    for i=0, dendidx.size()-1 { 
        sections[dendidx.x[i]] dend.append() 
    }
    
    basal = new SectionList()
    for i=0, basalidx.size()-1 { 
        sections[basalidx.x[i]] basal.append() 
    }
    
    apical = new SectionList()
    for i=0, apicalidx.size()-1 { 
        sections[apicalidx.x[i]] apical.append() 
    }
    
    axon     = new SectionList()
    allaxon  = new SectionList()
    ais      = new SectionList()
    hillock  = new SectionList()
    
    if (hilidx.size() > 0) {
        for i=0, hilidx.size()-1 {
            sections[hilidx.x[i]] {
                hillock.append()
                allaxon.append()
                all.append()
            }
        }
    }
    if (aisidx.size() > 0) {
        for i=0, aisidx.size()-1 {
            sections[aisidx.x[i]] {
                ais.append()
                allaxon.append()
                all.append()
            }
        }
    }
    
    for i=0, axonidx.size()-1 {
        sections[axonidx.x[i]] {
            axon.append()
            allaxon.append()
            all.append()
        }
    }

}

proc geom() {
    
    sections[0] {nseg=1 L=20 diam=15} // changed L & diam
    
        
    for i = 0,1 {
        sections[1+i*ndendsec+0] {nseg=3 L=50 diam=4} 	// dend 1 and 2 are basal
        sections[1+i*ndendsec+1] {nseg=3 L=50 diam=3}
        sections[1+i*ndendsec+2] {nseg=3 L=50 diam=2}
        sections[1+i*ndendsec+3] {nseg=3 L=50 diam=1} 
    }
    
    for i = 2,3 {
        sections[1+i*ndendsec+0] {nseg=3 L=75 diam=4}	// dend 3 and 4 are apical
        sections[1+i*ndendsec+1] {nseg=3 L=75 diam=3}
        sections[1+i*ndendsec+2] {nseg=3 L=75 diam=2}
        sections[1+i*ndendsec+3] {nseg=3 L=75 diam=1}
    }
}

func lambda_f() { local i, x, y, z, x1, x2, d1, d2, lam
    
    /*
    printf("lambda_f: n3d() = %d\n", n3d())
    if (n3d() <= 3) {
        for i=0, n3d()-1 {
            x = x3d(i)
            y = x3d(i)
            z = x3d(i)
            d = diam3d(i)
            printf("lambda_f: i = %d x = %g y = %g z = %g\n", i, x3d(i), y3d(i), z3d(i))
        }
    }
    */
    
    if (n3d() < 2) {
        return 1e5*sqrt(diam/(4*PI*$1*Ra*cm))
    }
    x1 = arc3d(0)
    d1 = diam3d(0)
    lam = 0
    for i=1, n3d()-1 {
        x2 = arc3d(i)
        d2 = diam3d(i)
        lam += (x2 - x1)/sqrt(d1 + d2)
        x1 = x2   d1 = d2
    }
    //  length of the section in units of lambda
    lam *= sqrt(2) * 1e-5*sqrt(4*PI*$1*Ra*cm)
    
    return L/lam
}

proc geom_nseg() { local freq, d_lambda
    
    freq = 100 // Hz, frequency at which AC length constant will be computed
    d_lambda = 0.1
    
    forsec all { nseg = int((L/(d_lambda*lambda_f(freq))+0.9)/2)*2 + 1  }

}

proc topol() {
    
    ndends = $1
    ndendsec = $2
    
    nDends = ndends*ndendsec
    
    connect sections[1+0*ndendsec+0](0), sections[0](1)
    connect sections[1+1*ndendsec+0](0), sections[0](1)
    connect sections[1+2*ndendsec+0](0), sections[0](0)
    connect sections[1+3*ndendsec+0](0), sections[0](0)
    
    for i=0,ndends-1 {
        for j=1,ndendsec-1 {
	    connect sections[1+i*ndendsec+j](0), sections[1+i*ndendsec+(j-1)](1)
        }
    }
}    


proc biophys() {

	// resting membrane potential. Must lie between Na+ and K+ reversal potentials
	Vrest=-61
	
	// Temperature of simulation
	celsius = 34.0  

	// Membrane resistance in ohm*cm2
	RmDend = 80000
	RmSoma = 80000

	// Membrane capacitance in uF/cm2
	CmSoma= 1.0
	CmDend = 1.0

	// Axial resistance in ohm*cm
	RaDend= 150
	RaSoma= 150
	
	// Calcium concentrations in mM
	ca_outside = 2
	ca_inside = 5.e-6
	catau = 10

	// reversal potentials in mV
	ekval = -90	
	enaval = 55
	eHCNval = -40
	ecaval = 8.314*(273.15+celsius)/(2*9.649e4)*log(ca_outside/ca_inside)*1000 // about 170, otherwise set to 130
        eleak = Vrest
	
	if (Vrest<ekval) Vrest=ekval // Cell cannot rest lower than K+ reversal potential
	if (Vrest>enaval) Vrest=enaval // Cell cannot rest higher than Na+ reversal potential
        
        g_leak_decay_dend = 4.5
        
	// max ion channel conductances in mho/cm2
 	gNav     = 0.005*1.8 // soma: // 0.12 //original 0.030 to .055 ; lm: //0.5  	//original 0.015
	gKdr     = 0.003    // Delayed rectifier potassium
 	gsKdr    = 0.0011 //0.1465/1
 	gKvA 	 = 0.0010 // Proximal A-type potassium
	gHCN     = 0.00002 // HCN (hyperpolarization-activated cyclic nucleotide-gated channel)
 	gCavN    = 0.00001 //   N-type calcium
 	gCavL    = 0.00025 //  L-type calcium
 	gKvCaB	 = 0.0001 // Big potassium channel: voltage and calcium gated 
	gKCaS	 = 0.02 //  Small potassium channel: calcium gated	
	gKvM	 = 0.06
        
	forsec soma { distance() }
        
	forsec all {
		insert iconc_Ca
		
		insert KAcck // KvA
		gmax_KAcck = gKvA		// A-type K+ conductance
		
		insert nca  			// N-type Ca2+ conductance
		gmax_nca = gCavN
		
		insert CavLcck
		gmax_CavLcck = gCavL
		
		insert gskch
		gbar_gskch = gKCaS
		
		insert KvCaB
		gmax_KvCaB = gKvCaB

		insert HCNcck
		gmax_HCN=gHCN

		Ra = RaSoma
	} 

	forsec soma {
		insert nax//cck	
		gbar_nax = gNav
		ena = enaval
                
		insert fKdrcck
		gmax_fKdrcck = gKdr
                
		insert sKdrcck
		gmax_sKdrcck = gsKdr
		
		insert KvM
		gmax_KvM = gKvM		// M-type K+ conductance
		
		insert pas
		g_pas = 1/RmSoma
                e_pas = eleak
                
		cm=CmSoma
	} 

	forsec dend {
            
		cm=CmDend
		
		for (x,0) {
		    insert pas
		    g_pas(x) = 1/RmDend * exp(-g_leak_decay_dend * distance(x)/1000)
                    e_pas = eleak
                    
		    insert nax//cck
		    gbar_nax(x)=gNav*.5
		    ena = enaval
                    
		    insert fKdrcck
		    gmax_fKdrcck(x)=gKdr //*10
                    
		    insert sKdrcck
		    gmax_sKdrcck(x) = gsKdr //*2
		}
	    }	
            
            
        forsec ais {
	        insert fKdrcck
	        gmax_fKdrcck = gKdr
	        insert nax
	        gbar_nax = gNav
	        insert pas
	        g_pas = 1/RmSoma
	        e_pas = eleak  	
            }
            
            forsec hillock {
	        insert fKdrcck
	        gmax_fKdrcck = gKdr
	        insert nax
	        gbar_nax = gNav
	        insert pas
	        g_pas = 1/RmSoma
	        e_pas = eleak  	
            }
            
            forsec axon {
	        insert fKdrcck
	        gmax_fKdrcck = gKdr
	        insert nax
	        gbar_nax = gNav
                
	        insert pas
	        g_pas = 1/RmSoma
	        e_pas = eleak  	
            }
    

    forsec all {
        ek = ekval
        ena = enaval
    }

    forsec allaxon {
        ek = ekval
        ena = enaval
    }

}


proc topol_from_python() { local i,j,p,s,dimsize localobj vidxs, vsrc, vdst, secnodes, swc_types
    
    secnodes  = $o1
    vsrc      = new Vector($o2)
    vdst      = new Vector($o3)
    swc_types = new Vector($o4)
    
    nDends = 0
    nSoma  = 0
    nAxon  = 0
    nAIS   = 0
    nHill  = 0
    
    for s = 0, secnodes.__len__()-1 {
        vidxs = new Vector(secnodes.__getitem__(s))
        i = vidxs.x[vidxs.size()-1]
        swc_type = swc_types.x[i]
        if (swc_type == 8) {
            hilidx.append(s)
            nHill = nHill + 1
            nAxon = nAxon + 1

        }
        if (swc_type == 7) {
            aisidx.append(s)
            nAIS = nAIS + 1
            nAxon = nAxon + 1
        }
        if (swc_type == 4) {
            apicalidx.append(s)
            dendidx.append(s)
            nDends = nDends + 1
        }
        if (swc_type == 3) {
            basalidx.append(s)
            dendidx.append(s)
            nDends = nDends + 1
        }
        if (swc_type == 2) {
            axonidx.append(s)
            nAxon = nAxon + 1
        }
        if (swc_type == 1) {
            somaidx.append(s)
            nSoma = nSoma+1
        }
    }
    
    create sections[nDends+nSoma+nAxon]
    for p = 0, vsrc.size-1 {
        i = vsrc.x[p]
        j = vdst.x[p]
        assert (i >= 0,  "compartment index in topology matrix is less than zero")
        assert (j >= 0,  "compartment index in topology matrix is less than zero")
        assert (i < nDends+nSoma+nAxon+1,  "compartment index in topology matrix is greater than the number of dendritic compartments")
        assert (j < nDends+nSoma+nAxon+1,  "compartment index in topology matrix is greater than the number of dendritic compartments")
        if (i == 0) {
            if (j == 1 || j == 2) {
                connect sections[j](0),sections[i](1)
            } else {
                connect sections[j](0),sections[i](0)
            }
        } else {
            connect sections[j](0),sections[i](1)
        }
        
    }
    
    vsrc.resize(0)
    vdst.resize(0)
    
}



proc shape_from_python() { local i,j,k,s localobj secnodes, vx, vy, vz, vradius, idxs, vidxs
    
    secnodes = $o1
    vx = new Vector($o2)
    vy = new Vector($o3)
    vz = new Vector($o4)
    vradius = new Vector($o5)
    
    for s=0, secnodes.__len__()-1 {
        idxs = secnodes.__getitem__(s)
        vidxs = new Vector()
        vidxs.from_python(idxs)
        sections[s] {
            k = vidxs.x[0]
            for i=0, vidxs.size()-1 {
                k = vidxs.x[i]
                pt3dadd(vx.x[k], vy.x[k], vz.x[k], 2*vradius.x[k]) 
            }
            pt3dconst(1)
        }
        
        
    }
    
    vx.resize(0)
    vy.resize(0)
    vz.resize(0)
    vradius.resize(0)
}


proc layers_from_python() { local i,j,k,s localobj secnodes, vlayer, seclayers, idxs, vidxs
    
    secnodes = $o1
    vlayer = new Vector($o2)
    
    for s=0, secnodes.__len__()-1 {
        layers.append(new Vector())
    }
    
    for s=0, secnodes.__len__()-1 {
        idxs = secnodes.__getitem__(s)
        vidxs = new Vector()
        vidxs.from_python(idxs)
        seclayers = layers.o(s)
        k = vidxs.x[0]
        for i=0, vidxs.size()-1 {
            k = vidxs.x[i]
            seclayers.append(vlayer.x[k])
        }
    }
    
    vlayer.resize(0)
}


func is_art()  { return 0 }

obfunc connect2target() { localobj nc // $o1 target point process, optional $o2 returned NetCon
    forsec soma {
        nc = new NetCon(&v(1), $o1)
    }
    nc.threshold = -20
    if (numarg() == 2) { $o2 = nc } // for backward compatibility
    return nc
}

proc position() { local i
    
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-xx+x3d(i), $2-yy+y3d(i), $3-zz+z3d(i), diam3d(i))
  }
  xx = $1  yy = $2  zz = $3
}



endtemplate HICAPCell