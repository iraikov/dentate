begintemplate BasketCell

public connect2target, subsets, is_art, is_connected
public soma, dendrites
public all, adend, bdend, cdend, ddend
public xx, yy, zz, position
public syns
public syn_stim, syntest

create soma, dendrites[1]

objref all, adend, bdend, cdend, ddend
objref adendidx, bdendidx, cdendidx, ddendidx
objref syns
objref syn_stim

id  = -1
gid = -1

ndends   = -1
ndendsec = -1
nDends   = -1

proc assert() { local test strdef errmsg
    
    test = $1
    errmsg = $s2
    
    if (!test) {
        execerror ("Assertion failed: ", errmsg)
    }
}

// dendrites 1 and 2 are apical
// dendrites 3 and 4 are basal

proc init() {
    
    // dendrites 1*ndendsec and 2*ndendsec are apical
    // dendrites 3*ndendsec and 4*ndendsec are basal
    
    adendidx = new Vector()
    bdendidx = new Vector()
    cdendidx = new Vector()
    ddendidx = new Vector()
    
    id  = $1
    gid = $2
    
    if (numarg() > 2) {
        topol_from_python($o4,$o5,$o6,$o7)
        shape_from_python($o7,$o8,$o9,$o10,$o11)
    } else {
        ndends   = 4
        ndendsec = 4
        create dendrites[ndends*ndendsec]
        
        i=0
        for j=0, ndendsec-1 { 
            adendidx.append(i*ndendsec + j)
        }
        i=1
        for j=0, ndendsec-1 { 
            bdendidx.append(i*ndendsec + j)
        }
        i=2
        for j=0, ndendsec-1 { 
            cdendidx.append(i*ndendsec + j)
        }
        i=3
        for j=0, ndendsec-1 { 
            ddendidx.append(i*ndendsec + j)
        }
        
        topol(ndends,ndendsec)
        geom()
    }
    subsets()
    geom_nseg()
    biophys()

    syns = new List()
    
    soma {
        syn_stim = new ExpSyn(0.5)
        syn_stim.tau = 2
    }

}

proc subsets() { local i, ndends, ndendsec
    
    objref all, adend, bdend, cdend, ddend
    
    all = new SectionList()
    soma all.append()
    for i=0, nDends-1 { 
        dendrites[i] all.append() 
    }
    
    adend  = new SectionList()
    for i=0, adendidx.size()-1 { 
        dendrites[adendidx.x[i]] adend.append() 
    }
    
    bdend  = new SectionList()
    for i=0, bdendidx.size()-1 { 
        dendrites[bdendidx.x[i]] bdend.append() 
    }
    
    cdend  = new SectionList()
    for i=0, cdendidx.size()-1 { 
        dendrites[cdendidx.x[i]] cdend.append() 
    }
    
    ddend  = new SectionList()
    for i=0, ddendidx.size()-1 { 
        dendrites[ddendidx.x[i]] ddend.append() 
    }

}

proc geom() {
    
    soma {nseg=1 L=20 diam=20} // changed L & diam
    
    for i = 0,1 {
        dendrites[i*ndendsec+0]  {nseg=1 L=75 diam=4}	// bcdend 1 and 2 are apical
        dendrites[i*ndendsec+1] {nseg=1 L=75 diam=3}
        dendrites[i*ndendsec+2] {nseg=1 L=75 diam=2}
        dendrites[i*ndendsec+3] {nseg=1 L=75 diam=1}
    }
        
    for i = 2,3 {
        dendrites[i*ndendsec+0] {nseg=1 L=50 diam=4} 	// bcdend 3 and 4 are basal
        dendrites[i*ndendsec+1] {nseg=1 L=50 diam=3}
        dendrites[i*ndendsec+2] {nseg=1 L=50 diam=2}
        dendrites[i*ndendsec+3] {nseg=1 L=50 diam=1} 
    }
}

func lambda_f() { local i, x, y, z, x1, x2, d1, d2, lam
    
    /*
    printf("lambda_f: n3d() = %d\n", n3d())
    if (n3d() <= 3) {
        for i=0, n3d()-1 {
            x = x3d(i)
            y = x3d(i)
            z = x3d(i)
            d = diam3d(i)
            printf("lambda_f: i = %d x = %g y = %g z = %g\n", i, x3d(i), y3d(i), z3d(i))
        }
    }
    */
    
    if (n3d() < 2) {
        return 1e5*sqrt(diam/(4*PI*$1*Ra*cm))
    }
    x1 = arc3d(0)
    d1 = diam3d(0)
    lam = 0
    for i=1, n3d()-1 {
        x2 = arc3d(i)
        d2 = diam3d(i)
        lam += (x2 - x1)/sqrt(d1 + d2)
        x1 = x2   d1 = d2
    }
    //  length of the section in units of lambda
    lam *= sqrt(2) * 1e-5*sqrt(4*PI*$1*Ra*cm)
    
    return L/lam
}

proc geom_nseg() {
  	forsec all { nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1  }
}

proc topol() {
    
    ndends = $1
    ndendsec = $2
    
    nDends = ndends*ndendsec
    
    connect dendrites[0*ndendsec+0](0), soma(1)
    connect dendrites[1*ndendsec+0](0), soma(1)
    connect dendrites[2*ndendsec+0](0), soma(0)
    connect dendrites[3*ndendsec+0](0), soma(0)
    
    for i=0,ndends-1 {
        for j=1,ndendsec-1 {
	    connect dendrites[i*ndendsec+j](0), dendrites[i*ndendsec+(j-1)](1)
        }
    }
}    


proc biophys() {
    
    forsec all {
        Ra=100
        cm=1.4
    }
    
    forsec all {
	insert ccanl
	catau_ccanl = 0.5
	caiinf_ccanl = 5.e-6
	insert borgka
	gkabar_borgka=0.00015
	insert nca  // HAV-N- Ca channel
	gncabar_nca=0.0008   
	insert lca 
	glcabar_lca=0.005
	insert gskch
	gskbar_gskch=0.000002
	insert cagk
	gkbar_cagk=0.0002
    }
  
    soma {
        insert ichan2  //ildikos ichan
	gnatbar_ichan2=0.12  
	gkfbar_ichan2=0.013  
	gl_ichan2 = 0.00018
    } 
    
    forsec adend {
        insert ichan2
	gnatbar_ichan2=0.12  
	gkfbar_ichan2=0.013
	gl_ichan2 = 0.00018
    }		
    
    forsec bdend {
        insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.00018
    }
    
    forsec cdend {
        insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.00018
    }
    
    forsec ddend {
        insert ichan2
	gnatbar_ichan2=0.0
	gkfbar_ichan2=0.00
	gl_ichan2 = 0.00018
    }
    
    
    forsec all {
        enat = 55 
        ekf  = -90  
        ek   = -90  
        elca = 130
        esk  = -90
        el_ichan2 =-60.06
        cao_ccanl=2
    }  
}


proc topol_from_python() { local i,j,p,s,dimsize localobj vidxs, vlayers, vsrc, vdst, secnodes, smembers, ndendpts
    
    // vlayers, vsrc, vdst, secnodes
    vlayers  = new Vector()
    vlayers.from_python($o1)
    vsrc     = new Vector()
    vsrc.from_python($o2)
    vdst     = new Vector()
    vdst.from_python($o3)
    secnodes = $o4
    smembers = new Vector()
    ndendpts = new Vector()
    
    nDends = secnodes.__len__()
    ndendpts.resize(nDends)
    for s=0, nDends-1 {
        vidxs = new Vector()
        vidxs.from_python(secnodes.__getitem__(s))
        ndendpts.x[s] = vidxs.size()
        for i=0, vidxs.size()-1 {
            p = vidxs.x[i]
            if (!smembers.contains(p)) {
                if (vlayers.x[p] == 0) {
                    adendidx.append(s)
                } else if (vlayers.x[p] == 1) {
                    bdendidx.append(s)
                } else if (vlayers.x[p] == 2) {
                    cdendidx.append(s)
                } else if (vlayers.x[p] >= 3) {
                    ddendidx.append(s)
                }
                smembers.append(p)
                break
            }
        }
    }
    
    na  = adendidx.size()
    nb  = bdendidx.size()
    nc  = cdendidx.size()
    nd  = ddendidx.size()
    
    create dendrites[nDends]
    for p = 0, vsrc.size-1 {
        i = vsrc.x[p]
        j = vdst.x[p]
        assert (i >= 0,  "compartment index in topology matrix is less than zero")
        assert (j >= 0,  "compartment index in topology matrix is less than zero")
        assert (i < nDends+1,  "compartment index in topology matrix is greater than the number of dendritic compartments")
        assert (j < nDends+1,  "compartment index in topology matrix is greater than the number of dendritic compartments")
        connect dendrites[j](0),dendrites[i](1)
        
    }
    connect dendrites[0](0),soma(1)
    
    vlayers.resize(0)
    vsrc.resize(0)
    vdst.resize(0)
    smembers.resize(0)
    
}



proc shape_from_python() { local i,j,k,s localobj secnodes, vx, vy, vz, vradius, idxs, vidxs
    
    secnodes = $o1
    vx = new Vector()
    vx.from_python($o2)
    vy = new Vector()
    vy.from_python($o3)
    vz = new Vector()
    vz.from_python($o4)
    vradius = new Vector()
    vradius.from_python($o5)
    
    for s=0, secnodes.__len__()-1 {
        idxs = secnodes.__getitem__(s)
        vidxs = new Vector()
        vidxs.from_python(idxs)
        dendrites[s] {
            pt3dconst(0)
            for i=0, vidxs.size()-1 {
                k = vidxs.x[i]
                pt3dadd(vx.x[k], vy.x[k], vz.x[k], vradius.x[k]) 
            }
        }
    }
    

    vx.resize(0)
    vy.resize(0)
    vz.resize(0)
    vradius.resize(0)
    
}


func is_art()  { return 0 }

obfunc connect2target() { localobj nc // $o1 target point process, optional $o2 returned NetCon
  soma nc = new NetCon(&v(1), $o1)
  nc.threshold = 10
  if (numarg() == 2) { $o2 = nc } // for backward compatibility
  return nc
}

proc position() { local i
    
  soma for i = 0, n3d()-1 {
    pt3dchange(i, $1-xx+x3d(i), $2-yy+y3d(i), $3-zz+z3d(i), diam3d(i))
  }
  xx = $1  yy = $2  zz = $3
}





endtemplate BasketCell
