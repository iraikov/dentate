/************************************************************
Current version:
Model-2.3
	more print options by MC		2009-10-15
Model-2.2
	Option-print ConMat/Pos by MC	2009-09-28
Model-2.1
	Print outs ASAP by Marianne		2009-09-08
Model-2.0
	Restructured by Marianne Case	2009-09-02
	Parallelized by Michael Hines	2009-08-03

Previous version:
50knet
	Inherited from Rob Morgan		2009-04-20

For the following details, consult the README.txt file:
Version History
Purpose of code
Input files
Output files
Code Outline

For even more information, consult ModelDoc.pdf
************************************************************/

loadstart = startsw()					// record the start time of the set up
/***********************************************************************************************
I.  LOAD LIBRARIES & PARAMETERS
***********************************************************************************************/
{load_file("nrngui.hoc")}				// Standard definitions - NEURON library file
{load_file("netparmpi.hoc")}			// Contains the template that defines the properties of the
										// 	ParallelNetManager class
{load_file("ranstream.hoc")}			// Defines a RandomStream class used to produce random numbers
										// 	for the cell noise
{load_file("CellCategoryInfo.hoc")}		// Defines a CellCategoryInfo class used to store
										// 	celltype-specific parameters
{load_file("parameters.hoc")}			// Loads in operational and model parameters

/***********************************************************************************************
II. SET MODEL SIZE, CELL DEFINITIONS
***********************************************************************************************/
objref f2								// Define object reference for the cells2include file
objref celltypestring[1], cellType[1]	// Define placeholder objects, redefine with correct size in fcn
double cellnumvar[1], cellLayerflag[1], numCellTypes[1]	// Define placeholder doubles, redefine with correct size in fcn
proc loadCellCategoryInfo() {local i, startpos	// Load celltype info into a CellCategoryInfo object, 1 per cell type 
	f2 = new File()
	f2.ropen("cells2include.hoc")
	numCellTypes = f2.scanvar			// # cell types, including pp cells

	objref celltypestring[numCellTypes], cellType[numCellTypes]	// Define variables to temporarily hold data scanned from file
	double cellnumvar[numCellTypes], cellLayerflag[numCellTypes]

	for i=0, numCellTypes-1 {
		celltypestring[i]= new String()
		f2.scanstr(celltypestring[i].s)	// Scan in the cell name
		cellnumvar[i]=f2.scanvar			// Scan in the initial (before sclerosis) number of each cell type
		cellLayerflag[i]=f2.scanvar			// Scan the layer flag (hilar=1, granular=0), where hilar cells
											//	are subject to sclerosis
	}
	f2.close()

	startpos=0
	for i=0, numCellTypes-1 {
	cellType[i] = new CellCategoryInfo(i)	// Make one object for each cell type to store cell type info
	cellType[i].setCellTypeParams(celltypestring[i].s, startpos, cellnumvar[i], cellLayerflag[i])	// Set parameters
	cellType[i].numCons = new Vector(numCellTypes,0)
	if (i>0) {cellType[i].setCellTypeDist}	// Load distribution file
	startpos = startpos + cellnumvar[i]		// Increment the startGid for the next cell type's call to setCellTypeParams
	}
}
loadCellCategoryInfo()

strdef tempFileStr						// Define string reference for the names of the cell template files
proc loadCellTemplates(){local i		// Define one template for each cell type in cells2include, plus perforant path cell(s)
	for i=0, numCellTypes-1 {
		sprint(tempFileStr,"./cells/class_%s.hoc",cellType[i].cellType_string)
		load_file(tempFileStr)			// Load the cell type's class template
	}
}	

loadCellTemplates()

proc calcNetSize(){local i				// Calculate final network size after sclerosis
	totalCells = 0						// Initialize totalCells so we can add to it iteratively in the for loop
	ncell = cellType[0].numCells		// Initialize ncell so we can add to it iteratively in the for loop
	for i=1,numCellTypes-1 {			// Run the following code for non ppstim cell types only
		if (cellType[i].killflag==1) {	// For cell types that are susceptible to sclerosis
			cellType[i].numCells = int(cellType[i].numCells * ((100-percentSclerosis)/100))	// Calculate the # of cells after sclerosis
			if (cellType[i].numCells == 0) {cellType[i].numCells = 1}		// If all cells of a type are killed, add 1 back
		}
		cellType[i].updateGidRange(cellType[i-1].cellEndGid+1)	// Update the gid ranges for each cell type
		totalCells = totalCells + cellType[i].numCells			// Total number of cells after sclerosis, not including pp cells
		ncell = ncell + cellType[i].numCells 					// Total # cells including pp cells
	}
	random_stream_offset_= (totalCells*2+2)	// How far down the stream to start the next stream section -
											// 	must be higher than the length of each stream section, which
											// 	is the # of times this thing will be called per cell x random type
}
calcNetSize()

/***********************************************************************************************
III.SET UP PARALLEL CAPABILITY
***********************************************************************************************/
objref pnm, pc, nc, nil
proc parallelizer() {
	pnm = new ParallelNetManager(ncell)	// Set up a parallel net manager for all the cells
	pc = pnm.pc
	pnm.round_robin()					// Incorporate all processors - cells 0 through ncell-1
										//	are distributed throughout the hosts
										//	(cell 0 goes to host 0, cell 1 to host 1, etc)
}
parallelizer()

iterator pcitr() {local i2, startgid	// Create iterator for use as a standard 'for' loop throughout given # cells
// usage:
// for pcitr(&i, &gid, it_start, it_end) {do stuff}	// it_start and it_end let you define range over which to iterate
	i1 = 0
	numcycles = int($3/pc.nhost)
	extra = $3%pc.nhost
	addcycle=0
	if (extra>pc.id) {addcycle=1}
	startgid=(numcycles+addcycle)*pc.nhost+pc.id
	if (startgid<=$4) {
		for (i2=startgid; i2 <= $4; i2 += pc.nhost) {	// Just iterate through the cells on this host
														//	(this works because of the roundrobin call made earlier)
				$&1 = i1
				$&2 = i2
				iterator_statement
				i1 += 1
		}
	}
}

proc typeout() {local i, rank, gid, srcid localobj tgt, f, cell// Write out the cell types & gid ranges
	pc.barrier()					// Wait for all ranks to get to this point
	f = new File("celltype.dat")
	if (pc.id == 0) { 				// Write header to file 1 time only
		f.wopen()
		f.printf("celltype\ttypeIndex\trangeStart\trangeEnd\n")
		for i=0, numCellTypes-1 {
			f.printf("%s\t%d\t%d\t%d\n", cellType[i].cellType_string, i, cellType[i].cellStartGid, cellType[i].cellEndGid)
		}
		f.close()
	}
}
typeout()

loadtime = startsw() - loadstart		// Calculate the set up time (now - recorded start time) in seconds
if (pc.id == 0) {printf("\nTIME HOST 0: %g seconds (set up)\n************\n", loadtime)}
createstart = startsw()					// Record the start time of the cell creation
/***********************************************************************************************
IV. CREATE, UNIQUELY ID, AND POSITION CELLS
***********************************************************************************************/
strdef cmd
objref cells, ranconlist, ransynlist
cells = new List()						
ranconlist = new List()
ransynlist = new List()
proc createCells(){ local i, si, pci, cellind, runresult, gid	// Create cells and assign a GID to each cell
	for cellind=1, numCellTypes-1 {
		if (strcmp(cellType[cellind].cellType_string,"mossycell")==0) {	// Update the seed for the random # generators
			usedseeds=noise_random_stream_offset_*(cellType[cellind].numCells+1)+1	// Calculate which section(s) of the random
		}																			//	number stream have already been used
	}

	for cellind=0, numCellTypes-1 {
		for pcitr(&i, &gid, cellType[cellind].cellStartGid, cellType[cellind].cellEndGid) {// use the pciter over all cells of this type
			if (pc.gid_exists(gid)) {
				sprint(cmd, "cellType[%g].CellList[%g]=new %s(%g)", cellind, i, cellType[cellind].cellType_string, gid+cellType[cellind].cellStartGid)
				runresult=execute1(cmd) 		// This command was written as a string so
												//	the cell object doesn't have to be hard coded
				cells.append(cellType[cellind].CellList[i])	// Append each cell to cells list
				ranconlist.append(new RandomStream(usedseeds+(gid*2)*random_stream_offset_))	// Create a new random number generator for each cell,
																	//	with a unique stream section defined by the starting location.  This
																	//	will be used to determinewhich connections are made
				ranconlist.object(int(gid/pc.nhost)).r.uniform(0,1)// Set up the generator to pick a uniform dist of numbers between 0 and 1

				ransynlist.append(new RandomStream(usedseeds+(gid*2+1)*random_stream_offset_))	// Create a new random number generator for each cell,
																								//	with a unique stream. This will be used to determine
																								//	what type of synapse is used in connections
				cellType[cellind].CellList[i].connect_pre(nil, nc)	// Create an empty connection for use by the spike detector
				pc.cell(gid, nc)									// Associate the cell with its gid and its spike generation location
				
				if (cellind>0) {									// For non ppstim cells, assign position, initialize synapse cid and sid
					for si=0, cellType[cellind].CellList[i].pre_list.count-1 {	// Iterate over each pre cell type's synapse list
						for j=0, cellType[cellind].CellList[i].pre_list.o(si).count-1 {		// Iterate through each synapse in the list
							cellType[cellind].CellList[i].pre_list.o(si).o(j).cid=gid			// Set the cell id for each synapse
																								//  Note: Parameters added to Syn2Gid mechanism
						}
					}
					xpos=pos_algorithm(gid,cellType[cellind].numCells,cellType[cellind].cellStartGid)	// Algorithmically generate cell position
					cellType[cellind].CellList[i].position(xpos,0,0)									// Record cell position in cell object
					
					if ((i%int(cellType[cellind].numCells/10+1) == 0) && (flagprint>1)) {print cellType[cellind].cellType_string, ": ", i}
				}
			}
		} 
	}

	nc = nil // Then clear the reference to the netcon object, which should destroy the netcon (because all refs would have been removed)
	if  (flagprint>0) {print "Host ", pc.id, " created cells."}
}
/**/func pos_algorithm() {local addamt CellNum // Arguments: gid, numCells, startGid; Return: x position of cell
		addamt=1
		CellNum=$1 - $3+1
		if ((dentateBins*CellNum)%$2==0) {addamt=0}
		return (int(dentateBins*CellNum/$2)+addamt-1)*dentateBinSize+dentateBinSize/2
	}
createCells()

proc posout() {local pci, rank, gid, srcid localobj tgt, f, cell	// Write out the 3d position coordinates of each cell
	pc.barrier()					// Wait for all ranks to get to this point
	f = new File("position.dat")
	if (pc.id == 0) { 				// Write header to file 1 time only
		f.wopen()
		f.printf("cell\tx\ty\tz\thost\n")
		f.close()
	}
	for rank = 0, pc.nhost-1 {				// For each processor, allow processor to append to file the positions of its cells
		if (rank == pc.id) {				// Ensure that each processor runs once
			f.aopen() 						// Open for appending to file
			for pcitr(&pci, &gid, cellType[1].cellStartGid, cellType[numCellTypes-1].cellEndGid) {		// Use the pciter over all non ppStim cells
				if (pc.gid_exists(gid)) {	// If cell exists on this machine
					cell = pc.gid2cell(gid)	// Refer to cell
					f.printf("%d\t%d\t%d\t%d\t%d\n", gid, cell.xx, cell.yy, cell.zz, pc.id)
				}
			}		
			f.close()
		}
		pc.barrier()
	}
}
if (printPosition>0) {posout()}	// Write the 3d position of each cell (gid, x, y, z), "position.dat"


createtime = startsw() - createstart	// Calculate time taken to create the cells
if (pc.id == 0) {printf("\nTIME HOST 0: %g seconds (created cells)\n************\n", createtime)}
connectstart = startsw()				// Grab start time of cell connection
/***********************************************************************************************
V.	CONNECT THE CELLS AND CONNECT THE PERFORANT PATH TO SOME CELLS
***********************************************************************************************/
objref distribution
strdef precellType_string, postcellType_string
proc makeConnections () {local precellType, postcellType, precellStart, precellEnd, postcellStart, postcellEnd, i, j
	distribution = new Vector()
	// Attempt to connect all cells of each pre and post type
	for i = 1, numCellTypes-1 {		// Don't connect pp stim cells here - they have own function later
		distribution = cellType[i].dist						// Load axon distribution vector for this cell type
		precellType_string =  cellType[i].cellType_string	// Load cell type string used to grab connection-specific properties later
		precellStart = cellType[i].cellStartGid				// Load cell type start gid
		precellEnd = cellType[i].cellEndGid					// Load cell type end gid

		for j = 1, numCellTypes-1 {	// ppstim cells are never the post synaptic cell in a connection, so exclude here
			postcellStart = cellType[j].cellStartGid		// Load cell type start gid
			postcellEnd = cellType[j].cellEndGid			// Load cell type end gid
			postcellType_string = cellType[j].cellType_string	// Load cell type string used to grab connection-specific properties later
			cellType[i].numCons.x[j]=connectCells (i, j, precellStart, precellEnd, postcellStart, postcellEnd, precellType_string, postcellType_string)
		}			
	}
	if ((flagprint>0)) {print "Host ", pc.id, " connected cells."}
}
	objref randnum, synRand
/**/func connectCells () {local counter, preNum, postNum, pcj, igid, jgid, xrand, precellType, postcellType, precellStart, precellEnd, postcellStart, postcellEnd, i, j, randSynNumber, pre_xpos, post_xpos, numSynTypes localobj cell
		// Args: precellType, postcellType, precellStart, precellEnd, postcellStart
		// 		 postcellEnd, precellType_string, postcellType_string.
		 precellType = $1
		 postcellType = $2
		 precellStart = $3
		 precellEnd = $4
		 postcellStart = $5
		 postcellEnd = $6
		 preNum =cellType[precellType].numCells		// Look up the number of cells of the pre-synaptic type
		 postNum =cellType[postcellType].numCells	// Look up the number of cells of the post-synaptic type
		 counter=0

		getSynapseData($s7, $s8)	// Given the pre and post cell types, look up the weight, delay,
									//	and probability of connection between these two types

		if (flagprint>1) {print "Host ", pc.id, " is connecting: ", $s7, "s to ", $s8, "s."}

		if (synProb != 0) {
			for pcitr(&j, &jgid, postcellStart, postcellEnd) {	// For each post-syn cell on this host (limit only the
																//	post-syn cell to ensure we try all connection possibilities
																//	(this limit ensures the hosts don't duplicate work)
				pcj=int(jgid/pc.nhost)
				numSynTypes = pc.gid2cell(jgid).pre_list.o(precellType).count
				post_xpos = pos_algorithm(jgid,postNum,postcellStart)	// Calculate the position algorithmically rather than trying to look it up
				ransynlist.object(pcj).r.discunif(0,numSynTypes-1)		// Create a uniform random INTEGER variable over the range specified (0 to # synapse types-1),
				for igid = precellStart, precellEnd {					// For each pre-syn cell
					pre_xpos=pos_algorithm(igid,preNum,precellStart)	// Calculate the position algorithmically
					distNumber = dentateBins + ((pre_xpos - post_xpos) / dentateBinSize) 	// This arrangement and the distribution file
																							//	arrangement mimics an absolute value function
																							//	for the # bins between cells
					if (ranconlist.object(pcj).repick < (connectionFactor * synProb * distribution.x[distNumber-1])) { // Determine whether a
																							//	connection will be made between these two cells
						randSynNumber = ransynlist.object(pcj).repick	// Randomly pick a synapse type from the available synapse types
						nc_append(igid, jgid, precellType, randSynNumber, synWeight, synDelay)	// Make the connection
						counter +=1
					}
				}    
			} 
		}
		return counter
	}
		objref  f2
/**/	proc getSynapseData () {	// Args: precelltype name, postcelltype name
			 strdef tempString
			 f2 = new File()

			 sprint(tempString,"%s.%s",$s1,$s2)	// Get the file that specifies connection properties between these two cell types
			 f2.ropen(tempString)
			 synWeight = f2.scanvar
			 synDelay = f2.scanvar
			 synProb = f2.scanvar
			 if ((strcmp($s1,"granulecell")==0) && (strcmp($s2,"granulecell")==0) && (randnet==0)) {synProb = synProb * percentSclerosis/100}
		}	 	// Reduce the probability of granule cell connection by the same degree as the sclerosis
				//	because mossy fibers connecting back to granule cells are subject to sclerosis (?)
		objref nclist
		nclist = new List()
/**/	func nc_append() { localobj cell, nc	// Connect cell to synapse and set synapse properties

			if (pc.gid_exists($2)) {			// Check if cell exists on this machine
				cell = pc.gid2cell($2)
				nc = pc.gid_connect($1, cell.pre_list.o($3).o($4))	// Connect the soma of the pre cell to the synapse on the post cell
				nc.weight = $5					// Set a synaptic connection weight
				nc.delay = $6					// Set a delay time (axonal delay)
				nclist.append(nc)
			}
			return nclist.count-1
		}
makeConnections()								// Try making connections between every type of cell

proc perfPathConns() { local i, pci, jgid, celltype, counter		// Connect the perforant path cells to the model cells
	for i= cellType[0].cellStartGid, cellType[0].cellEndGid {
		for celltype=1, numCellTypes-1 {
			if (strcmp(cellType[celltype].cellType_string,"granulecell")==0) {	// Connect to some granule cells
				// Make 1 connection to each cell in the middle 10% (45th - 54th percentiles) of the cell group
				for pcitr(&pci, &jgid, cellType[celltype].cellStartGid + int(45/100*cellType[celltype].numCells) - 1, cellType[celltype].cellStartGid + int(54/100*cellType[celltype].numCells) - 1) {
					nc_append(i, jgid, celltype, 0, 2e-2, 3)  
					nc_append(i, jgid, celltype, 1, 2e-2, 3) 
					cellType[0].numCons.x[celltype] +=2
				}
			}
			if (strcmp(cellType[celltype].cellType_string,"basketcell")==0) {	// Connect to some basket cells
				// Make 1 connection to each cell in the middle 10% (45th - 54th percentiles) of the cell group
				for pcitr(&pci, &jgid, cellType[celltype].cellStartGid + int(45/100*cellType[celltype].numCells) - 1, cellType[celltype].cellStartGid + int(54/100*cellType[celltype].numCells) - 1) {
					nc_append(i, jgid, celltype, 0, 1e-2, 3) 
					nc_append(i, jgid, celltype, 1, 1e-2, 3)  
					cellType[0].numCons.x[celltype] +=2
				}	
			}
			if (strcmp(cellType[celltype].cellType_string,"mossycell")==0) {	// Connect to some mossy cells
				// Make 10 connections to the middle 10% (45th - 54th percentiles) of mossy cells; may make multiple connections on one cell
				for j = 45, 54 {
					jgid=cellType[celltype].cellStartGid + int(j/100*cellType[celltype].numCells) -1
					if (pc.gid_exists(jgid)) {
						ransynlist.object(int(jgid/pc.nhost)).r.discunif(0,3)	// There are 4 types of synapses pp can make onto mossy cells
						nc_append(i, jgid, celltype, ransynlist.object(int(jgid/pc.nhost)).repick, 1.75e-2, 3)
						cellType[0].numCons.x[celltype] +=1
					}
				}
			}
		}
	}
}
perfPathConns()									// Make connections between the perforant path and some cells

proc printNumConFile() {local i, j localobj f
	pc.barrier()									// Wait for all ranks to get to this point
	f = new File("numcons.dat")
	if (pc.id == 0) { 								// Write header to file 1 time only
		f.wopen()
		f.printf("host\tpretype\tposttype\tnumCons\n")
		f.close()
	}
	for rank = 0, pc.nhost-1 {				// For each processor, allow processor to append to file the positions of its cells
		if (rank == pc.id) {				// Ensure that each processor runs once
			f.aopen() 						// Open for appending to file
			for i = 0, numCellTypes-1 {
				for j = 0, numCellTypes-1 {
					f.printf("%g\t%d\t%d\t%d\n", pc.id, i, j, cellType[i].numCons.x[j])	// Print host id, precell type, postcell type, num connections
				}
			}
			f.close()
		}		
		pc.barrier()
	}
}
if (printNumCon==1) {printNumConFile()}	// Write a summary file of all cell connections by pre and post cell types "numcons.dat"

proc tracenet() {local i, rank, srcid localobj tgt, f	// Write out the connections list, including synapse type
	pc.barrier()									// Wait for all ranks to get to this point
	f = new File("connections.dat")
	if (pc.id == 0) { 								// Write header to file 1 time only
		f.wopen()
		f.printf("source\ttarget\tsynapse\n")
		f.close()
	}
	for rank = 0, pc.nhost-1 {				// For each processor, allow processor to append to file the positions of its cells
		if (rank == pc.id) {				// Ensure that each processor runs once
			f.aopen() 						// Open for appending to file
			for i=0, nclist.count -1 {		// For each connection in the list
				srcid = nclist.o(i).srcgid()	// Get the gid of the source cell
				tgt = nclist.o(i).syn			// Get a reference to the target cell
				f.printf("%d\t%d\t%d\n", srcid, tgt.cid, tgt.sid)	// Print source gid, target gid, synapse id
			}
			f.close()
		}		
		pc.barrier()
	}
}
if (printConMat==2) {tracenet()}	// Write the file of all cell connections (pre and post gids, synapse type, host on which cell exists), "connections.dat"


connecttime = startsw() - connectstart			// calculate time taken to connect the cells
if (pc.id == 0) {printf("\nTIME HOST 0: %g seconds (connected cells)\n************\n", connecttime)}
runstart = startsw()							// grab start time of the simulation
/***********************************************************************************************
VI.	INITIALIZE AND RUN NETWORK, OUTPUT RESULT FILES
***********************************************************************************************/
proc init() { local dtsav, temp, secsav, secondordersav	// initialize the simulation
	dtsav = dt						// Save desired dt value to reset after temporarily changing dt
	secondordersav = secondorder	// Save desired secondorder value to reset after temporarily changing secondorder

	finitialize(v_init)	// Call finitialize (since we are replacing the default init proc that calls this)
						// finitialize will Call the INITIAL block for all mechanisms and point processes inserted in the sections
						//	and set the initial voltage to v_init for all sections

	t = -500			// Set the start time for (pre) simulation; -500 to prepare network in advance of start at 0
	dt= 10				// Set dt to large value
	secondorder = 0		// Set secondorder to 0 to set the default fully implicit backward euler for numerical integration (see NEURON ref)
		
	temp= cvode.active()
	if (temp!=0) {cvode.active(0)}	// If cvode is on, turn off temporarily to do large fixed step
	// Now, do a large pre run from t = -500 to t = -100 to set the network 'settle' and all components to reach steady state
	while(t<-100) { fadvance() if (flagprint>1) {print t}}	// Integrate all section equations over the interval dt. increment t by dt
															//	and repeat till t at -100
	if (temp!=0) {cvode.active(1)}	// If cvode was on and then turned off, turn it back on now
	
	t = tstart 						// Start time of the simulation
	dt = dtsav						// Reset dt to specified value
	secondorder = secondordersav	// Reset secondorder to specified value
	if (cvode.active()){
		cvode.re_init()				// If cvode is active, initialize the integrator
	} else {
		fcurrent()					// If cvode is not active, make all assigned variables (currents, conductances, etc)
									//	consistent with the values of the states
	}
}

proc rrun(){												// Run the network simulation
	pnm.want_all_spikes() 						// Record all spikes of all cells on this machine into the pnm.spikevec (spiketimes) and pnm.idvec (gids)
	pc.set_maxstep(10)							// Set every machine's max step size to minimum delay of all netcons created on pc using pc.gid_connect, but not larger than 10
	stdinit()									// Call the init fcn (which is redefined in this code) and then make other standard calls (to stop watch, etc)
	pc.psolve(tstop)							// Equivalent to calling cvode.solve(tstop), for parallel NEURON, where solve will be broken into steps determined by the result of set_maxstep
	runtime = startsw() - runstart				// Calculate runtime of simulation
	if (pc.id == 0) {printf("****\nTIME SUMMARY for host 0\nset up in %g seconds\ncreated cells in %g seconds\nconnected cells in %g seconds\nran simulation in %g seconds\n************\n", loadtime, createtime, connecttime, runtime)}
	spikeout()	// Write the file of spike times and spiking cells, "spikeraster.dat"
	timeout()	// Write out a file of run times for each code section
	if (printConMat==1) {tracenet()}	// Write the file of all cell connections (pre and post gids, synapse type, host on which cell exists), "connections.dat"
}
/**/proc spikeout() {local i, rank  localobj f				// Write out a spike raster (cell, spike time)
		pc.barrier()									// Wait for all ranks to get to this point
		f = new File("spikeraster.dat")
		if (pc.id == 0) { 								// Write header to file 1 time only
			f.wopen()
			f.close()
		}
		
		for rank = 0, pc.nhost-1 {				// For each processor, allow processor to append to file the positions of its cells
			if (rank == pc.id) {				// Ensure that each processor runs once
				f.aopen() 						// Open for appending to file
				for i=0, pnm.idvec.size-1 {
					f.printf("%.3f %d\n", pnm.spikevec.x[i], pnm.idvec.x[i])	// Print the spike time and spiking cell gid
				}
				f.close()
			}
			pc.barrier()
		}
	}

/**/proc timeout() {local i, rank, gid, srcid localobj tgt, f, cell// Write out the 3d position coordinates of each cell
		pc.barrier()					// Wait for all ranks to get to this point
		f = new File("runtimes.dat")
		if (pc.id == 0) { 				// Write header to file 1 time only
			f.wopen()
			f.printf("host\tset up\tcreated cells\tconnected cells\tran simulation\t\n")
			f.close()
		}
		
		for rank = 0, pc.nhost-1 {				// For each processor, allow processor to append its runtimes to file
			if (rank == pc.id) {				// Ensure that each processor runs once
				f.aopen() 						// Open for appending to file
				f.printf("%g\t%g\t%g\t%g\t%g\n", pc.id, loadtime, createtime, connecttime, runtime)
				f.close()
			}
			pc.barrier()
		}
	}

rrun()	// Run the network simulation
quit()	// Quit the program when finished to return control to command line
