
// Dictionary template
{xopen("./templates/Dict.hoc")}

proc assert() { local test strdef errmsg
    
    test = $1
    errmsg = $s2
    
    if (!test) {
        execerror ("Assertion failed: ", errmsg)
    }
}

// Finds and loads a template located either in ./template or in externalPaths
proc find_template() { local status localobj externalPaths strdef cmd, path, templatePath, templateName
    
  externalPaths = $o1
  templateName = $s2

  path = "./templates"
  sprint(templatePath, "%s/%s.hoc", path, templateName)
  sprint(cmd, "test -e %s", templatePath) // check if the path exist
  status = system(cmd)
  if (status == 0) {
    sprint(cmd, "load_file(\"%s\")", templatePath)
    execute(cmd)
  } else {
    for i =0,externalPaths.count()-1 {
      path = externalPaths.o(i).s
      sprint(templatePath, "%s/%s.hoc", path, templateName)
      sprint(cmd, "test -e %s", templatePath) // check if the path exist
      status = system(cmd)
      if (status == 0) {
        sprint(cmd, "load_file(\"%s\")", templatePath)
        execute(cmd)
        break
      }
    }
  }
}

// Writes out connectivity graph
proc graphout() { local i,j,node localobj f, v, conlist
    f = new File($s1)
    conlist = $o2
    f.wopen()
    for i=0, conlist.count()-1 {
        v = conlist.object(i)
        node = v.x[0]
        for j=1, v.size()-1 {
            f.printf("%d %d\n", node, v.x[j])
        }
    }
    f.close()
}

// Writes out spike time information
proc spikeout() { local i localobj f, spikevec, idvec
    
    f = new File($s1)
    spikevec = $o2
    idvec = $o3
    
    f.wopen()
    for i=0, spikevec.size-1 {
	f.printf("%g %d\n", spikevec.x[i], idvec.x[i])
    }
    f.close()
}

// Returns the index of the named cell type or -1 if the type was not found
func findCellType() { local i, result localobj cellTypes, cellType
    
    strdef typeName
    
    cellTypes = $o1
    typeName = $s2
    
    result = -1
    
    for i=0, cellTypes.count()-1 {
        
        cellType = cellTypes.o(i)
        if (strcmp(typeName, cellType.getPropertyString("typeName").s) == 0) {
            result = i
            break
        }
        
    }
    
    return result
}

// Loads cell type info into a Dict
proc loadCellCategoryInfo() { local i, numCells, offset, minIndex, maxIndex localobj f, ff, cellTypes, cellType, indices
    
    strdef cellTypeName, cellTypeTemplateName, indexType, indexFileName, datasetPath, indexPath, errmsg
    
    // The first argument must be a list
    cellTypes = $o1
    
    // The second argument must be the path to the cell types file 
    f = new File()
    f.ropen($s2)
    
    // The third argument must be the path to the directory containing all datasets
    datasetPath = $s3
    
    // Scan the first line, which contains the number of cell types
    numCellTypes = f.scanvar()
    
    offset = 0
    for i=0, numCellTypes-1 {
        
        cellType = new Dict(cellTypeName)

        // Scan in the cell name, template name, number of cells
	f.scanstr(indexType)
        
        // population size is specified as cardinality (= set size)
        if (strcmp(indexType,"cardinality:") == 0) {
	    numCells = f.scanvar()
            
            cellType.addPropertyScalar("offset",offset)
            offset = offset + numCells
        } else if (strcmp(indexType,"indexfile:") == 0) {
	    f.scanstr(indexFileName)
            cellType.addPropertyString("indexFileName",indexFileName)
            sprint(indexPath,"%s/%s",datasetPath,indexFileName)
            indices = new Vector()
            ff = new File()
            ff.ropen(indexPath)
	    numCells = ff.scanvar()
            ff.scanvar()
            indices.buffer_size(numCells)
            indices.scanf(ff,numCells)
            ff.close(indexPath)
            minIndex = indices.min()
            maxIndex = indices.max()
            if (offset > minIndex) {
                sprint(errmsg,"loadCellCategoryInfo: current offset %d overlaps with minimum index (%d) in file %s",offset,minIndex,indexPath)
                execerror(errmsg)
            } 
            cellType.addPropertyScalar("offset",minIndex)
            cellType.addPropertyObject("indices",indices)
            offset = maxIndex+1
        } else {
            sprint(errmsg, "loadCellCategoryInfo: unknown index type %s", indexType)
            execerror(errmsg)
        }
	f.scanstr(cellTypeName)
	f.scanstr(cellTypeTemplateName)
        cellType.addPropertyScalar("numCells",numCells) 
        cellType.addPropertyString("typeName",cellTypeName)
        cellType.addPropertyString("templateName",cellTypeTemplateName)
        
        cellTypes.append(cellType)
    }
    f.close()
    
}

// Loads connectivity info into a Dict
proc loadConnectivityInfo() { local i, order, synIndex, wdType, standardWeight, standardVelocity, numConnectivityTypes localobj f, connectivityTypes, connectivityType
    
    strdef connectivityName, preSynapticPopulation, postSynapticPopulation
    
    // The first argument must be a list
    connectivityTypes = $o1
    
    // The second argument must be the path to the main connection file 
    f = new File()
    f.ropen($s2)
    
    // Scan the first line, which contains the number of connectivity matrices
    numConnectivityTypes = f.scanvar()
    if (verbose > 0) {
       printf ("numConnectivityTypes = %d\n", numConnectivityTypes)
    }

    for i=0, numConnectivityTypes-1 {

        // Read in the connectivity cell id numbering (0 - relative, 1 - absolute)
	order = f.scanvar()
        // Read in the connectivity name
	f.scanstr(connectivityName)
        // Read in the name of the presynaptic population
	f.scanstr(preSynapticPopulation)
        // Read in the name of the postsynaptic population
	f.scanstr(postSynapticPopulation)
        // Read in the post-synaptic index (-1 for artificial cells, -2 random selection)
	synIndex = f.scanvar()
        // Read in the type of weight+delay specification
	wdType = f.scanvar()
        if (verbose > 0) {
          printf ("ConnectivityType: i = %d\n", i)
          printf ("ConnectivityType: name = %s\n", connectivityName)
          printf ("ConnectivityType: pre = %s\n", preSynapticPopulation)
          printf ("ConnectivityType: post = %s\n", postSynapticPopulation)
          printf ("ConnectivityType: synIndex = %d\n", synIndex)
          printf ("ConnectivityType: wdType = %d\n", wdType)
        }
        if (wdType == 1) {
            connectivityType = new Dict(connectivityName)
            connectivityType.addPropertyString("name",connectivityName)
            connectivityType.addPropertyString("presynapticPopulation",preSynapticPopulation)
            connectivityType.addPropertyString("postsynapticPopulation",postSynapticPopulation)
            connectivityType.addPropertyScalar("synIndex",synIndex)
            connectivityType.addPropertyScalar("wdType",wdType)
            connectivityType.addPropertyScalar("order",order)
            connectivityTypes.append(connectivityType)
        } else if (wdType == 2) {
            standardWeight = f.scanvar()
            standardVelocity = f.scanvar()
            connectivityType = new Dict(connectivityName)
            connectivityType.addPropertyString("name",connectivityName)
            connectivityType.addPropertyString("presynapticPopulation",preSynapticPopulation)
            connectivityType.addPropertyString("postsynapticPopulation",postSynapticPopulation)
            connectivityType.addPropertyScalar("synIndex",synIndex)
            connectivityType.addPropertyScalar("wdType",wdType)
            connectivityType.addPropertyScalar("standardWeight",standardWeight)
            connectivityType.addPropertyScalar("standardVelocity",standardVelocity)
            connectivityType.addPropertyScalar("order",order)
            connectivityTypes.append(connectivityType)
        }
    }
    f.close()
    
}


// Loads gap junction info into a Dict
proc loadGapJunctionInfo() { local i, order, numGJTypes localobj f, gjTypes, gjType
    
    strdef gjName, srcPopulation, destPopulation
    
    // The first argument must be a list
    gjTypes = $o1
    
    // The second argument must be the path to the main connection file 
    f = new File()
    f.ropen($s2)
    
    // Scan the first line, which contains the number of connectivity matrices
    numGJTypes = f.scanvar()
    
    for i=0, numGJTypes-1 {
        
        // Read in the cell id numbering (0 - relative, 1 - absolute)
	order = f.scanvar()
        // Read in the gap junction connectivity name
	f.scanstr(gjName)
        // Read in the name of the source population
	f.scanstr(srcPopulation)
        // Read in the name of the destination population
	f.scanstr(destPopulation)
        gjType = new Dict(gjName)
        gjType.addPropertyString("name",gjName)
        gjType.addPropertyString("srcPopulation",srcPopulation)
        gjType.addPropertyString("destPopulation",destPopulation)
        gjType.addPropertyScalar("order",order)
        gjTypes.append(gjType)
    }
    f.close()
    
}


proc loadStimulationParameters() { localobj f, m strdef stimulationPath
    
    m = $o1
    stimulationPath = $s2
    f = new File(stimulationPath)
    f.ropen()
    m.scanf(f)
    f.close()
    
}