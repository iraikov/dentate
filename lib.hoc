
objref strfun
strfun = new StringFunctions()

proc assert() { local test strdef errmsg
    
    test = $1
    errmsg = $s2
    
    if (!test) {
        execerror ("Assertion failed: ", errmsg)
    }
}


// prints all the sections of the given cell
proc printCellSections() { localobj cell strdef typeName
    typeName = $s1
    cell = $o2
    if (strfun.is_artificial(cell) == 0) {
      printf("Cell type %s:\n", typeName)
      forsec cell.all { psection() }
    }
}



// Adds a network connection to a single synapse point process
proc mknetcon() { local srcgid, dstgid localobj syn, pc, nclist, nc strdef errmsg
    pc      = $o1
    nclist  = $o2
    srcgid  = $3
    dstgid  = $4
    syn     = $o5
    nc = pc.gid_connect(srcgid, syn)
    nc.weight = $6
    nc.delay = $7
    nclist.append(nc)
}


proc nc_appendsyn() {local w, i, se, lsrc, ltar localobj nc, pc, cell, syn, nclist strdef errmsg
    pc       = $o1
    nclist   = $o2
    lsrc     = $3
    ltar     = $4
    syn      = $o5
    w        = $6
    del      = $7
    // target in this subset
    // source may be on this or another machine
    sprint(errmsg,"nc_appendsyn: gid %d does not exist on host %d",ltar,pc.id())
    assert (pc.gid_exists(ltar), errmsg)
    if (pc.gid_exists(ltar)) {
        cell = pc.gid2cell(ltar)
	mknetcon(pc, nclist, lsrc, ltar, syn, w/1000.0, del)
    }
}


// A variant of ParallelNetManager.nc_append that 1) takes in a
// synaptic point process as an argument (as opposed to the index of a
// synapse in cell.synlist) and 2) chooses the synaptic
// weight from a predefined vector of synaptic weights for this
// connection type
proc nc_appendsyn_wgtvector() {local i, se, lsrc, ltar, del, wsize, widx localobj w, nc, pc, cell, syn, nclist strdef errmsg
    pc       = $o1
    nclist   = $o2
    lsrc     = $3
    ltar     = $4
    syn      = $o5
    w        = $o6
    wsize    = w.size()
    del      = $7
    sprint(errmsg,"nc_appendsyn_wgtvector: gid %d does not exist on host %d",ltar,pc.id())
    assert (pc.gid_exists(ltar), errmsg)
    // target in this subset
    // source may be on this or another machine
    cell = pc.gid2cell(ltar)
    widx = ltar % wsize
    mknetcon(pc, nclist, lsrc, ltar, syn, w.x[widx]/1000.0, del)
}


// help function to create gap junctions
proc mkgap() { local gid, sgid, dgid, w localobj pc, cell, gj, gjlist
    
    pc     = $o1
    gjlist = $o2
    gid    = $3
    sec    = $4
    sgid   = $5
    dgid   = $6
    w      = $7
    
    cell = pc.gid2cell(gid)
    
    //printf ("host %d: gap junction: gid = %d branch = %d sec = %d coupling = %g sgid = %d dgid = %d\n", pc.id, gid, branch, sec, w, sgid, dgid)
    
    //cell.dendrites[sec] { 
    cell.sections[sec] { 
        gj = new ggap(0.5) 
        pc.source_var(&v(0.5), sgid)
        pc.target_var(gj, &gj.vgap, dgid)
    }
    
    gjlist.append(gj)
    gj.g = w
    
    
}


// Finds and loads a template located either in ./template or in externalPaths
proc find_template() { local status, found localobj pc, externalPaths, foundv, f strdef path, templatePath, templateName, msg
    
  pc = $o1
  externalPaths = $o2
  templateName = $s3
  
  found = 0
  foundv = new Vector(1)
  f = new File()
  
  if (pc.id() == 0) {
      path = "./templates"
      sprint(templatePath, "%s/%s.hoc", path, templateName)
      status = f.ropen(templatePath)
      if (status == 1) {
          f.close()
          found = 1
          foundv.x[0] = found
      } else {
          for i =0,externalPaths.count()-1 {
              path = externalPaths.o(i).s
              sprint(templatePath, "%s/%s.hoc", path, templateName)
              status = f.ropen(templatePath)
              if (status == 1) {
                  f.close()
                  found = 1
                  foundv.x[0] = found
                  break
              }
          }
      }
  }
  pc.broadcast(foundv, 0)
  found  = foundv.x[0]
  
  if (found == 0) {
      sprint(msg,"unable to find template %s",templateName)
      execerror("find_template",msg)
  }
  
  pc.broadcast(templatePath, 0)
  load_file(templatePath)
  
}

// Writes out connectivity graph
proc graphout() { local i,j,node localobj f, v, conlist
    f = new File($s1)
    conlist = $o2
    f.wopen()
    for i=0, conlist.count()-1 {
        v = conlist.object(i)
        node = v.x[0]
        for j=1, v.size()-1 {
            f.printf("%d %d\n", node, v.x[j])
        }
    }
    f.close()
}

// Writes out spike time information
proc spikeout() { local i localobj f, spikevec, idvec
    
    f = new File($s1)
    spikevec = $o2
    idvec = $o3
    
    f.wopen()
    for i=0, spikevec.size-1 {
	f.printf("%.8g\t%d\n", spikevec.x[i], idvec.x[i])
    }
    f.close()
}

// Returns the index of the named cell type or -1 if the type was not found
func findCellType() { local i, result localobj cellTypes, cellType
    
    strdef typeName
    
    cellTypes = $o1
    typeName = $s2
    
    result = -1
    
    for i=0, cellTypes.count()-1 {
        
        cellType = cellTypes.o(i)
        if (strcmp(typeName, cellType.getPropertyString("typeName").s) == 0) {
            result = i
            break
        }
        
    }
    
    return result
}

// Loads stimulation data and initializes vecstim cells
proc loadVectorStimulation() {local sendpos, celltype_idx, startgid, endgid, pop_size localobj pc, f, vindex, vspiketimes, vsizes, vcellspikes, vgids, vactive, cell strdef vecstim_index_filename, vecstim_active_filename, vecstim_filename
    
    pc = $o1
    vgids = $o2
    vecstim_index_filename=$s3
    vecstim_filename=$s4
    vecstim_active_filename=$s5
    
    vindex       = new Vector()
    vspiketimes  = new Vector()
    vsizes       = new Vector()
    vactive      = new Vector()
    
    pop_size = vgids.size()
    
    
    if (pc.id() == 0) {
        
        f = new File ()
        
        status = f.ropen (vecstim_index_filename)
        vindex.vread(f)
        f.close()
        
        status = f.ropen (vecstim_filename)
        vspiketimes.vread(f)
        f.close()

	status = f.ropen (vecstim_active_filename)
        if (status > 0) {
           vactive.vread(f)
        } else {
           // if active file does not exist, assume all cells are active
           vactive.resize(vindex.size())
           vactive.fill(1)
        }
        f.close()
        
        vsizes.resize(vindex.size())
        for (i=0; i < vindex.size()-1; i+=1) {
            vsizes.x[i] = vindex.x[i+1] - vindex.x[i]
        }
        vsizes.x[vindex.size()-1] = vspiketimes.size() - vindex.x[vindex.size()-1]
    }
    
    // send out the number of spike entries each rank is going to receive
    pc.broadcast(vsizes, 0)
    pc.broadcast(vindex, 0)
    pc.broadcast(vspiketimes, 0)
    pc.broadcast(vactive, 0)

    for (i=0; i < vgids.size(); i+=1) {
	gid = vgids.x[i]
	if (pc.gid_exists(gid)  && (vactive.x[i] > 0)) {
	    vcellspikes = new Vector()
	    vcellspikes.copy(vspiketimes, 0, vindex.x[i], vindex.x[i]+vsizes.x[i]-1)
	    cell = pc.gid2cell(gid)
            cell.play(vcellspikes)
	}
    }
}




walltime_status = 0
dt_status = 1.0

proc simstatus() { local wt 
    wt = startsw()
    if (walltime_status > 0) {
        if (pc.id() == 0) {
            printf("*** rank 0 computation time at t=%g ms was %g s\n", t, wt-walltime_status)
        }
    }
    walltime_status = wt
    if (t + dt_status < tstop) {
        cvode.event(t + dt_status, "simstatus()")
    }
}

tcsum = 0
tcma = 0
nsimsteps = 0

walltime_checksimtime = 0
dt_checksimtime = 5.0

proc checksimtime() { local wt, tt, trem, tsimrem, min_tsimrem, tsimneeded, max_tsimneeded, tstop1, min_tstop localobj pc
    pc = $o1
    wt = startsw()
    if (t > 0) {
        tt = wt-walltime_checksimtime
        // cumulative moving average simulation time per dt_checksimtime
        tcma = tcma + (tt - tcma) / (nsimsteps + 1)
        tcsum = tcsum + tt
        // remaining physical time
        trem = tstop - t
        // remaining simulation time
        tsimrem = max_walltime_hrs*3600 - tcsum - mkcellstime - connectcellstime - connectgjstime
        min_tsimrem = pc.allreduce(tsimrem, 3) // minimum value
        // simulation time necessary to complete the simulation
        tsimneeded = (trem/dt_checksimtime)*tcma+results_write_time
        max_tsimneeded = pc.allreduce(tsimneeded, 2) // maximum value
        if (pc.id() == 0) {
            //printf("trem = %g tcsum = %g tsimrem = %g tcma = %g tsimneeded = %g max_tsimneeded = %g\n",trem,tcsum,tsimrem,tcma,tsimneeded,max_tsimneeded)
            printf("*** remaining computation time is %g s and remaining simulation time is %g ms\n", tsimrem, trem)
            printf("*** estimated computation time to completion is %g s\n", max_tsimneeded)
        }
        if (max_tsimneeded > min_tsimrem) {
            tstop1 = int((tsimrem - results_write_time)/(tcma/dt_checksimtime)) + t
            min_tstop = pc.allreduce(tstop1, 3) // minimum value
            if (pc.id() == 0) {
     	        printf ("*** not enough time to complete %g ms simulation, simulation will likely stop around %g ms\n", tstop, min_tstop)
            }
            if (min_tstop <= t) {
                tstop = t+dt
            } else {
                tstop = min_tstop
            }
            cvode.event(tstop)
        }
	nsimsteps = nsimsteps + 1
    }
    walltime_checksimtime = wt
    if (t + dt_checksimtime < tstop) {
        cvode.event(t + dt_checksimtime, "checksimtime(pc)")
    }

 }
 
dt_vrecord = 0.1
objref my_indicesVrecord, vrecordlog

vrecordlog = new List()

proc vrecord() { local status, gid, i localobj pnm, cell, vec strdef cmd
    
    pnm = $o1
    
    sprint(cmd, "my_indicesVrecord = indicesVrecord")
    status = execute(cmd)

    vec = new Vector(my_indicesVrecord.count())
    for i=0, my_indicesVrecord.count()-1 {
        gid  = my_indicesVrecord.o(i).n
        cell = pnm.pc.gid2cell(gid)
        if (strfun.is_artificial(cell) == 0) {
           vec.x[i] = cell.soma.v
        }
    }
    vrecordlog.prepend(vec)
    if (t + dt_vrecord < tstop) {
      cvode.event(t + dt_vrecord, "vrecord(pnm)")
    }
}

// Writes out voltage traces
proc vrecordout() { local i, j, status localobj f, vec, lst, indices

    indices = $o2
    
    lst = new List()
    for i=0, vrecordlog.count()-1 {
        lst.prepend(vrecordlog.o(i))
    }

    f = new File($s1)
    
    f.wopen()
    f.printf("# ")
    for i=0, indices.count()-1 {
	f.printf("%d ", indices.o(i).n)
    }
    f.printf("\n")
    for i=0, lst.count()-1 {
        vec = lst.o(i)
	f.printf("%g ", i*dt_vrecord)
	for j=0, vec.size()-1 {
	   f.printf("%g ", vec.x[j])
        }
        f.printf("\n")
    }
    f.close()
}

