
objref strfun
strfun = new StringFunctions()

proc assert() { local test strdef errmsg
    
    test = $1
    errmsg = $s2
    
    if (!test) {
        execerror ("Assertion failed: ", errmsg)
    }
}


// prints all the sections of the given cell
proc printCellSections() { localobj cell strdef typeName
    typeName = $s1
    cell = $o2
    if (strfun.is_artificial(cell) == 0) {
      printf("Cell type %s:\n", typeName)
      forsec cell.all { psection() }
    }
}

// Adds a network connection to a single synapse in a list
proc mknetcon1() { local srcgid, dstgid, index localobj synlist, pc, nclist, nc strdef errmsg
    pc      = $o1
    nclist  = $o2
    srcgid  = $3
    dstgid  = $4
    synlist = $o5
    index   = $6
    if (index < synlist.count()) {
        nc = pc.gid_connect(srcgid, synlist.o(index))
        nc.weight = $7
	nc.delay = $8
	nclist.append(nc)
    }
    sprint(errmsg,"mknetcon1: connection %d -> %d: synapse index %d is greater than total number of synapses (%d)",srcgid,dstgid,index,synlist.count())
    assert (index < synlist.count(), errmsg)
}


// Adds network connections to all synapses in a list
proc mknetcon() { local i localobj synlist, nclist, pc, nc
    pc      = $o1
    nclist  = $o2
    src     = $3
    synlist = $o4
    for i=0, synlist.count()-1 {
        nc = pc.gid_connect(src, synlist.o(i))
        nc.weight = $5
        nc.delay = $6
        nclist.append(nc)
    }
}



// A variant of ParallelNetManager.nc_append that takes in a synaptic
// point process as an argument (as opposed to the index of a synapse in cell.synlist)
func nc_appendsyn() {local i, se, lsrc, ltar localobj w, nc, pc, cell, synlist, nclist, synIndex strdef errmsg
    i = 0
    pc       = $o1
    nclist   = $o2
    lsrc     = $3
    ltar     = $4
    synIndex = $o5
    w        = $o6
    del      = $7
    // target in this subset
    // source may be on this or another machine
    sprint(errmsg,"nc_appendsyn: gid %d does not exist on host %d",ltar,pc.id())
//    assert (pc.gid_exists(ltar), errmsg)
    if (pc.gid_exists(ltar)) {
    cell = pc.gid2cell(ltar)
    assert (synIndex.is_undefined == 0,"synIndex is undefined")
    i = nclist.count()
    if (synIndex.is_number) {
        mknetcon(pc, nclist, lsrc, cell.syns.o(synIndex.n), w.n/1000.0, del)
    } else {
        mknetcon(pc, nclist, lsrc, cell.syns.o(synIndex.l.o(0).n), w.l.o(0).n/1000.0, del)
        mknetcon(pc, nclist, lsrc, cell.syns.o(synIndex.l.o(1).n), w.l.o(1).n/1000.0, del)
    }
    }
    return i
}


// A variant of ParallelNetManager.nc_append that 1) takes in a
// synaptic point process as an argument (as opposed to the index of a
// synapse in cell.synlist) and 2) chooses the synaptic
// weight from a predefined vector of synaptic weights for this
// connection type
func nc_appendsyn_wgtvector() {local i, se, lsrc, ltar, del, wsize, synidx, widx localobj w, nc, pc, cell, synlist, nclist, synType, synIndex strdef errmsg
    i = -1
    pc       = $o1
    nclist   = $o2
    lsrc     = $3
    ltar     = $4
    synType  = $o5
    synIndex = $o6
    w        = $o7
    wsize    = w.size()
    del      = $8
    sprint(errmsg,"nc_appendsyn_wgtvector: gid %d does not exist on host %d",ltar,pc.id())
    assert (pc.gid_exists(ltar), errmsg)
    // target in this subset
    // source may be on this or another machine
    cell = pc.gid2cell(ltar)
    i = nclist.count()
    if (synType.is_number) {
      synidx = synIndex.n
      widx = (ltar + synidx) % wsize
      mknetcon1(pc, nclist, lsrc, ltar, cell.allsyns.o(synType.n), synidx, w.x[widx]/1000.0, del)
    } else {
      execerror ("Unsupported synapse type")
    }
    return i
}


// helper function to create synapses
proc mksyn() { local i, dendnum, compnum localobj cell, nc, syn, riseTime, decayTime, erev, dend, comp, count, rsdend, rscomp, dendindex, compindex strdef cellTypeName

    cell = $o1
    riseTime = $o2
    decayTime = $o3
    erev = $o4
    dend = $o5 
    comp = $o6
    rsdend = $o7
    rscomp = $o8
    cellTypeName = $s9

    if (verbose > 0) {
        printf ("mksyn: cellTypeName = %s dend.count = %d comp.count = %d\n", cellTypeName, dend.count(), comp.count())
    }
    
    // TODO: use count property for total number of synapses to create
    rsdend.r.discunif(1,4)
    rscomp.r.discunif(1,4)

    for i = 0, dend.count()-1 {

        dendindex = dend.o(i)
        compindex = comp.o(i)
        
        assert (dendindex.is_undefined == 0,"mksyn: dendindex is undefined")
        assert (compindex.is_undefined == 0,"mksyn: compindex is undefined")
        
        if (dendindex.is_nil) { continue }

        if (dendindex.is_list) {

            dendnum = rsdend.repick() % (dendindex.l.o(1).n+1)
            if (compindex.is_list) {
              compnum = rscomp.repick() % (compindex.l.o(1).n+1)
            } else {
              compnum = compindex.n
            }
            
            if (verbose > 0) {
                printf ("mksyn: cellTypeName = %s dendnum = %d compnum = %d\n", cellTypeName, dendnum, compnum)
            }

            cell.dendrites[dendnum][compnum] {
                
	        syn = new Exp2Syn(0.5)
                syn.tau1 = riseTime.o(i).n
                syn.tau2 = decayTime.o(i).n
                syn.e = erev.o(i).n
    		cell.syns.o(i).append(syn)
            }
            
 	} else if (dendindex.is_number) {
            
            dendnum = dendindex.n
	    if (compindex.is_list) {
                compnum = rscomp.repick() % (compindex.l.o(1).n+1)
            } else {
                compnum = compindex.n
            }
            
            if (verbose > 0) {
                printf ("mksyn (dendindex is a number): cellTypeName = %s dendnum = %d compnum = %d\n", cellTypeName, dendnum, compnum)
            }
            
            cell.dendrites[dendnum][compnum] {
	        syn = new Exp2Syn(0.5)
                syn.tau1 = riseTime.o(i).n
                syn.tau2 = decayTime.o(i).n
                syn.e = erev.o(i).n
    		cell.syns.o(i).append(syn)
            }
            
 	} else {
            
            if (verbose > 0) {
                printf ("mksyn: cellTypeName = %s synapse in soma\n", cellTypeName)
            }
            
            cell.soma {
	        syn = new Exp2Syn(0.5)
                syn.tau1 = riseTime.o(i).n
                syn.tau2 = decayTime.o(i).n
                syn.e = erev.o(i).n
    		cell.syns.o(i).append(syn)
                
            }
        }
        
    }
    
    
}

// help function to create gap junctions
proc mkgap() { local gid, sgid, dgid, w localobj pc, cell, gj, gjlist
    
    pc     = $o1
    gjlist = $o2
    gid    = $3
    branch = $4
    sec    = $5
    sgid   = $6
    dgid   = $7
    w      = $8
    
    cell = pc.gid2cell(gid)
    
    //printf ("host %d: gap junction: gid = %d branch = %d sec = %d coupling = %g sgid = %d dgid = %d\n", pc.id, gid, branch, sec, w, sgid, dgid)
    
    cell.dendrites[branch][sec] { 
        gj = new ggap(0.5) 
        pc.source_var(&v(0.5), sgid)
        pc.target_var(gj, &gj.vgap, dgid)
    }
    
    gjlist.append(gj)
    gj.g = w
    
    
}


// Finds and loads a template located either in ./template or in externalPaths
proc find_template() { local status, found localobj externalPaths strdef cmd, path, templatePath, templateName, msg
    
  externalPaths = $o1
  templateName = $s2

  found = 0
  path = "./templates"
  sprint(templatePath, "%s/%s.hoc", path, templateName)
  sprint(cmd, "test -e %s", templatePath) // check if the path exist
  status = system(cmd)
  if (status == 0) {
    found = 1
    sprint(cmd, "load_file(\"%s\")", templatePath)
    status = execute1(cmd)
    if (status == 0) {
      sprint(msg,"unable to load template %s",templateName)
      execerror("find_template",msg)
    }
  } else {
    for i =0,externalPaths.count()-1 {
      path = externalPaths.o(i).s
      sprint(templatePath, "%s/%s.hoc", path, templateName)
      sprint(cmd, "test -e %s", templatePath) // check if the path exist
      status = system(cmd)
      if (status == 0) {
        found = 1
        sprint(cmd, "load_file(\"%s\")", templatePath)
        status = execute1(cmd)
        if (status == 0) {
          sprint(msg,"unable to load template %s",templateName)
          execerror("find_template",msg)
        }
        break
      }
    }
  }
  if (found == 0) {
      sprint(msg,"unable to find template %s",templateName)
      execerror("find_template",msg)
  }
}

// Writes out connectivity graph
proc graphout() { local i,j,node localobj f, v, conlist
    f = new File($s1)
    conlist = $o2
    f.wopen()
    for i=0, conlist.count()-1 {
        v = conlist.object(i)
        node = v.x[0]
        for j=1, v.size()-1 {
            f.printf("%d %d\n", node, v.x[j])
        }
    }
    f.close()
}

// Writes out spike time information
proc spikeout() { local i localobj f, spikevec, idvec
    
    f = new File($s1)
    spikevec = $o2
    idvec = $o3
    
    f.wopen()
    for i=0, spikevec.size-1 {
	f.printf("%.8g\t%d\n", spikevec.x[i], idvec.x[i])
    }
    f.close()
}

// Returns the index of the named cell type or -1 if the type was not found
func findCellType() { local i, result localobj cellTypes, cellType
    
    strdef typeName
    
    cellTypes = $o1
    typeName = $s2
    
    result = -1
    
    for i=0, cellTypes.count()-1 {
        
        cellType = cellTypes.o(i)
        if (strcmp(typeName, cellType.getPropertyString("typeName").s) == 0) {
            result = i
            break
        }
        
    }
    
    return result
}

// Loads stimulation data and initializes vecstim cells
proc loadVectorStimulation() {local sendpos, celltype_idx, startgid, endgid, pop_size localobj pc, f, vindex, vspiketimes, vsizes, vcellspikes, vgids, vactive, cell strdef vecstim_index_filename, vecstim_active_filename, vecstim_filename
    
    pc = $o1
    vgids = $o2
    vecstim_index_filename=$s3
    vecstim_filename=$s4
    vecstim_active_filename=$s5
    
    vindex       = new Vector()
    vspiketimes  = new Vector()
    vsizes       = new Vector()
    vactive      = new Vector()
    
    pop_size = vgids.size()
    
    
    if (pc.id == 0) {
        
        f = new File ()
        
        status = f.ropen (vecstim_index_filename)
        vindex.vread(f)
        f.close()
        
        status = f.ropen (vecstim_filename)
        vspiketimes.vread(f)
        f.close()

	status = f.ropen (vecstim_active_filename)
        if (status > 0) {
           vactive.vread(f)
        } else {
           // if active file does not exist, assume all cells are active
           vactive.resize(vindex.size())
           vactive.fill(1)
        }
        f.close()
        
        vsizes.resize(vindex.size())
        for (i=0; i < vindex.size()-1; i+=1) {
            vsizes.x[i] = vindex.x[i+1] - vindex.x[i]
        }
        vsizes.x[vindex.size()-1] = vspiketimes.size() - vindex.x[vindex.size()-1]
    }
    
    // send out the number of spike entries each rank is going to receive
    pc.broadcast(vsizes, 0)
    pc.broadcast(vindex, 0)
    pc.broadcast(vspiketimes, 0)
    pc.broadcast(vactive, 0)

    for (i=0; i < vgids.size(); i+=1) {
	gid = vgids.x[i]
	if (pc.gid_exists(gid)  && (vactive.x[i] > 0)) {
	    vcellspikes = new Vector()
	    vcellspikes.copy(vspiketimes, 0, vindex.x[i], vindex.x[i]+vsizes.x[i]-1)
	    cell = pc.gid2cell(gid)
            cell.play(vcellspikes)
	}
    }
}




walltime_status = 0
dt_status = 1.0

proc simstatus() { local wt 
    wt = startsw()
    if (walltime_status > 0) {
        if (pc.id() == 0) {
            printf("*** rank 0 computation time at t=%g ms was %g s\n", t, wt-walltime_status)
        }
    }
    walltime_status = wt
    if (t + dt_status < tstop) {
        cvode.event(t + dt_status, "simstatus()")
    }
}

tcsum = 0
tcma = 0
nsimsteps = 0

walltime_checksimtime = 0
dt_checksimtime = 5.0

proc checksimtime() { local wt, tt, trem, tsimrem, min_tsimrem, tsimneeded, max_tsimneeded, tstop1, min_tstop localobj pc
    pc = $o1
    wt = startsw()
    if (t > 0) {
        tt = wt-walltime_checksimtime
        // cumulative moving average simulation time per dt_checksimtime
        tcma = tcma + (tt - tcma) / (nsimsteps + 1)
        tcsum = tcsum + tt
        // remaining physical time
        trem = tstop - t
        // remaining simulation time
        tsimrem = max_walltime_hrs*3600 - tcsum - mkcellstime - connectcellstime - connectgjstime
        min_tsimrem = pc.allreduce(tsimrem, 3) // minimum value
        // simulation time necessary to complete the simulation
        tsimneeded = (trem/dt_checksimtime)*tcma+results_write_time
        max_tsimneeded = pc.allreduce(tsimneeded, 2) // maximum value
        if (pc.id() == 0) {
            //printf("trem = %g tcsum = %g tsimrem = %g tcma = %g tsimneeded = %g max_tsimneeded = %g\n",trem,tcsum,tsimrem,tcma,tsimneeded,max_tsimneeded)
            printf("*** remaining computation time is %g s and remaining simulation time is %g ms\n", tsimrem, trem)
            printf("*** estimated computation time to completion is %g s\n", max_tsimneeded)
        }
        if (max_tsimneeded > min_tsimrem) {
            tstop1 = int((tsimrem - results_write_time)/(tcma/dt_checksimtime)) + t
            min_tstop = pc.allreduce(tstop1, 3) // minimum value
            if (pc.id() == 0) {
     	        printf ("*** not enough time to complete %g ms simulation, simulation will likely stop around %g ms\n", tstop, min_tstop)
            }
            if (min_tstop <= t) {
                tstop = t+dt
            } else {
                tstop = min_tstop
            }
            cvode.event(tstop)
        }
	nsimsteps = nsimsteps + 1
    }
    walltime_checksimtime = wt
    if (t + dt_checksimtime < tstop) {
        cvode.event(t + dt_checksimtime, "checksimtime(pc)")
    }

 }
 
dt_vrecord = 0.1
objref my_indicesVrecord, vrecordlog

vrecordlog = new List()

proc vrecord() { local status, gid, i localobj pnm, cell, vec strdef cmd
    
    pnm = $o1
    
    sprint(cmd, "my_indicesVrecord = indicesVrecord")
    status = execute(cmd)

    vec = new Vector(my_indicesVrecord.count())
    for i=0, my_indicesVrecord.count()-1 {
        gid  = my_indicesVrecord.o(i).n
        cell = pnm.pc.gid2cell(gid)
        if (strfun.is_artificial(cell) == 0) {
           vec.x[i] = cell.soma.v
        }
    }
    vrecordlog.prepend(vec)
    if (t + dt_vrecord < tstop) {
      cvode.event(t + dt_vrecord, "vrecord(pnm)")
    }
}

// Writes out voltage traces
proc vrecordout() { local i, j, status localobj f, vec, lst, indices

    indices = $o2
    
    lst = new List()
    for i=0, vrecordlog.count()-1 {
        lst.prepend(vrecordlog.o(i))
    }

    f = new File($s1)
    
    f.wopen()
    f.printf("# ")
    for i=0, indices.count()-1 {
	f.printf("%d ", indices.o(i).n)
    }
    f.printf("\n")
    for i=0, lst.count()-1 {
        vec = lst.o(i)
	f.printf("%g ", i*dt_vrecord)
	for j=0, vec.size()-1 {
	   f.printf("%g ", vec.x[j])
        }
        f.printf("\n")
    }
    f.close()
}

