{load_file("nrngui.hoc")}  // loads the gui and standard run libraries
{load_file("netparmpi.hoc")} // parallelnetmanager definitions

 // directories external to this project that contain additional templates and mechanisms
objref externalPaths
strdef modelName, datasetPrefix, datasetName, datasetPath

// parameters must be the name of a file specified on the command line
// as follows: nrniv -c "strdef parameters" -c "parameters=\"parameters.hoc\""
{load_file(parameters)}


{xopen("lib.hoc")}

// path to the dataset directory
sprint(datasetPath, "%s/%s", datasetPrefix, datasetName)

nrn_load_dll("mechanisms/x86_64/.libs/libnrnmech.so")

strdef path, mechanismsPath
// Load mechanisms from external location
for i =0,externalPaths.count()-1 {
    path = externalPaths.o(i).s
    sprint(mechanismsPath, "%s/x86_64/.libs/libnrnmech.so", path)
    nrn_load_dll(mechanismsPath)
}

// used to calculate model construction times and run time
mkcellstime = 0
connectcellstime = 0
connectgjstime = 0
runtime = 0


// used for executing command strings
strdef cmd

// path for various datafiles (used for multiple files)
strdef datafilePath

// randomstream template
{load_file("./templates/ranstream.hoc")}

// list with cell type information
objref cellTypes
cellTypes = new List()

// used to keep track of artificial stimulus cells
objref ncstimlist

// reads the cell types file and populates celltypes with the information
sprint (datafilePath, "%s/celltypes.dat", datasetPath)
loadCellCategoryInfo (cellTypes, datafilePath)

// total number of cells in the network
ncells = 0
strdef templatename
objref celltype
for i=0, cellTypes.count()-1 { 
    celltype = cellTypes.o(i)
    ncells = ncells + celltype.getPropertyScalar("numCells")
}
if (verbose > 0) {
    printf ("%s: ncells = %d\n", modelName, ncells)
}


// list with connectivity information
objref connectivityTypes
connectivityTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/connectivity.dat", datasetPath)
loadConnectivityInfo (connectivityTypes, datafilePath)

// list with gap junction information
objref gjTypes
gjTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/gapjunctions.dat", datasetPath)
loadGapJunctionInfo (gjTypes, datafilePath)

// pnm.cells is a list that holds all instances of network cells that
// exist on this host

// pnm.nclist holds all netcon instances that exist on this host

objref pnm

pnm = new ParallelNetManager(ncells)

pnm.round_robin()

// each noise generator picks a number every
// dt for the full time range, so stream
// sections must be at least this long to
// prevent overlap
noise_random_stream_offset_ = tstop/dt + 1	

// connectivity list local to the current mpi process
objref conlist
if (makegraph > 0) {
    conlist = new List()
}

// gap junction connectivity list local to the current mpi process
objref gjconlist
if (makegraph > 0) {
    gjconlist = new List()
}

// gap junction list local to the current mpi process
objref gjlist
gjlist = new List()

/* mkcells and connectcells create the cells and connect the cells */

// used for the creation of cells
objref cell, nc

// creates the cells and appends them to a list called cells
// argument is the number of cells to be created
proc mkcells() { local nCellTypes, numCells, i, j, p, node, nodeSize, nodeNumber, treeHeight  localobj cellTypes, cellType, datadirIndex strdef templateName, typeName, datadir
    
    cellTypes = $o1
    nCellTypes = cellTypes.count()
    
    for k=0, nCellTypes-1 { 
        cellType = cellTypes.o(k)
        typeName = cellType.getPropertyString("typeName").s
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset = cellType.getPropertyScalar("offset")
        if (strcmp(templateName, "NetStim") != 0) {
            find_template(externalPaths, templateName)
            // For cell templates that load their morphologies from
            // external files, set the maximum number of files per
            // directory to 5000, and calculate the maximum height (or
            // depth) of the directory tree necessary to store all
            // files for that cell type.
            nodeSize = 5000 
            if (numCells > nodeSize) {
                nodeNumber = int(numCells / nodeSize)
                treeHeight = int((log10(nodeNumber+1) / log10(2))+1)
                for i=0, numCells-1 { 
                    datadir=""
                    if (pnm.gid_exists(offset+i)) {
                        node=int(i/nodeSize)
                        for (j=treeHeight-1; j >= 0; j = j-1) {
                            p = 2^j
                            if (node >= p) {
                                node = node-p
                                sprint(datadir, "%s/1", datadir)
                            } else {
                                sprint(datadir, "%s/0", datadir)
                            }
                        }
                        sprint(cmd, "cell = new %s(%d, %d, \"%s/%s%s\")", templateName, offset+i, noise_random_stream_offset_, datasetPath, typeName, datadir)
                        execute(cmd)
	                pnm.register_cell(offset+i, cell)
                    }
                }
            } else {
                for i=0, numCells-1 { 
                    if (pnm.gid_exists(offset+i)) {
                        sprint(cmd, "cell = new %s(%d, %d, \"%s/%s/\")", templateName, offset+i, noise_random_stream_offset_, datasetPath, typeName)
                        execute(cmd)
	                pnm.register_cell(offset+i, cell)
                    }
                }
            }
        } else {
            // Used to keep track of artificial stimulus cells
            typeName = cellType.getPropertyString("typeName").s
            sprint (cmd, "objref %slist, nc%slist", typeName, typeName)
            execute(cmd)
            sprint (cmd, "%slist = new List()", typeName)
            execute(cmd)
            sprint (cmd, "nc%slist = new List()", typeName)
            execute(cmd)
            for i=0, numCells-1 { 
                if (pnm.gid_exists(offset+i)) {
                    cell = new NetStim(0.0)
                    pnm.register_cell(offset+i, cell)
                }
            }
        }
    }
}

// connects the cells
// appends the NetCon objects to nclist
proc connectcells() {local i, k, srcid, destid, srcid1, destid1, w, del, dist, velocity, ncid, synIndex, wdType, order, presynapticSize, postsynapticSize, stimsrc localobj presynapticType, postsynapticType, cellTypes, connectivityType, connectivityTypes, nc, edges, m, f, stim
    
    strdef connectivityPath, connectivityName, presynapticPopulation, postsynapticPopulation
    connectivityTypes = $o1
    cellTypes = $o2
    nConnectivityTypes = connectivityTypes.count()
    
    for k=0, nConnectivityTypes-1 { 
        connectivityType = connectivityTypes.o(k)
        order = connectivityType.getPropertyScalar("order")
        synIndex = connectivityType.getPropertyScalar("synIndex")
        wdType = connectivityType.getPropertyScalar("wdType")
        connectivityName = connectivityType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("connectivityName = %s\n", connectivityName)
        }
        presynapticPopulation = connectivityType.getPropertyString("presynapticPopulation").s
        postsynapticPopulation = connectivityType.getPropertyString("postsynapticPopulation").s
        presynapticType = cellTypes.o(findCellType(cellTypes,presynapticPopulation))
        postsynapticType = cellTypes.o(findCellType(cellTypes,postsynapticPopulation))
        presynapticSize = presynapticType.getPropertyScalar("numCells")
        postsynapticSize = postsynapticType.getPropertyScalar("numCells")
        presynapticOffset = presynapticType.getPropertyScalar("offset")
        postsynapticOffset = postsynapticType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("presynaptic population = %s\n", presynapticPopulation)
            printf ("presynaptic size = %d\n", presynapticSize)
            printf ("postsynaptic population = %s\n", postsynapticPopulation)
            printf ("postsynaptic size = %d\n", postsynapticSize)
        }
        if (strcmp(presynapticType.getPropertyString("templateName").s, "NetStim") == 0) {
            stimsrc = 1
            sprint(cmd, "ncstimlist = nc%slist", presynapticPopulation)
            execute(cmd)
        } else {
            stimsrc = 0
        }
        sprint(connectivityPath, "%s/%s.dat", datasetPath, connectivityName)
        m = new Matrix()
        f = new File(connectivityPath)
        f.ropen()
        m.scanf(f)
        f.close()
        if ((stimsrc == 1) && (wdType == 1)) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                nc = pnm.pc.gid_connect(srcid1, pnm.pc.gid2obj(destid1).synlist.object(synIndex))
                w = m.x[i][2]
                del = m.x[i][3]
                nc.weight = w
                nc.delay = del
                ncstimlist.append(nc)
                if (verbose > 0) {
                    printf ("artificial stimulus: srcid = %d destid = %d weight = %g delay = %g\n", srcid1, destid1, nc.weight, nc.delay)
                    print "postsynaptic cell = ", pnm.pc.gid2obj(destid)
                }
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                conlist.prepend(edges)
            }
        } else if (wdType == 1) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                w = m.x[i][2]
                del = m.x[i][3]
                // The third argument is synapse index or -1 for point processes
	        ncid = pnm.nc_append(srcid1, destid1, synIndex, w, del)
                nc = pnm.nclist.o(ncid)
                if (verbose > 0) {
                    printf ("connection: srcid = %d destid = %d weight = %g delay = %g\n", srcid1, destid1, nc.weight, nc.delay)
                }
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                conlist.prepend(edges)
            }
        } else if (wdType == 2) {
            w = connectivityType.getPropertyScalar("standardWeight")
            velocity = connectivityType.getPropertyScalar("standardVelocity")
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                dist = m.x[i][2] + m.x[i][3]
                del = dist / velocity
                // The third argument is synapse index or -1 for point processes
	        ncid = pnm.nc_append(srcid1, destid1, synIndex, w, del)
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                conlist.prepend(edges)
            }
        }
    }
}

proc mkgap() { local gid, sgid, dgid, w localobj cell, gj, gjlist
    
    gjlist = $o1
    gid  = $2
    dgid = $3
    sgid = $4
    w    = $5
    
    cell = pnm.pc.gid2cell(gid)
    
    cell.soma { 
        gj = new ggap(0.5) 
        pnm.pc.target_var(gj, &gj.vgap, dgid)
        pnm.pc.source_var(&cell.soma.v(0.5), sgid)
    }
    
    gjlist.append(gj)
    gj.g = w
    
    if (verbose > 0) {
        printf ("gap junction: gid = %d coupling = %g sgid = %d dgid = %d\n", gid, w, sgid, dgid)
    }
    
}

// creates the gap junctions between cells
proc connectgjs() {local i, k, w, ggid, srcid, destid, srcid1, destid1, order, srcSize, destSize localobj srcType, destType, cellTypes, gjType, gjTypes, edges, m, f
    
    strdef gjPath, gjName, srcPopulation, destPopulation
    gjTypes = $o1
    cellTypes = $o2
    nGJTypes = gjTypes.count()
    ggid = 2*ncells
    
    for k=0, nGJTypes-1 { 
        ggid = ggid+2
        gjType = gjTypes.o(k)
        order  = gjType.getPropertyScalar("order")
        gjName = gjType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("gjName = %s\n", gjName)
        }
        srcPopulation  = gjType.getPropertyString("srcPopulation").s
        destPopulation = gjType.getPropertyString("destPopulation").s
        srcType    = cellTypes.o(findCellType(cellTypes,srcPopulation))
        destType   = cellTypes.o(findCellType(cellTypes,destPopulation))
        srcSize    = srcType.getPropertyScalar("numCells")
        destSize   = destType.getPropertyScalar("numCells")
        srcOffset  = srcType.getPropertyScalar("offset")
        destOffset = destType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("src population = %s\n", srcPopulation)
            printf ("src size = %d\n", srcSize)
            printf ("dest population = %s\n", destPopulation)
            printf ("dest size = %d\n", destSize)
        }
        sprint(gjPath, "%s/%s.dat", datasetPath, gjName)
        m = new Matrix()
        f = new File(gjPath)
        f.ropen()
        m.scanf(f)
        f.close()
        for i=0, m.nrow-1 {
            srcid = m.x[i][0]
            destid = m.x[i][1]
            w = m.x[i][2]
            if (order == 0) {
                // relative numbering of pre/post synaptic cells -- add the respective offsets
                assert (srcid < srcSize, "source cell id is greater than the size of the src population")
                assert (destid < destSize, "destination cell id is greater than the size of the dest population")
                srcid1 = srcid + srcOffset
                destid1 = destid + destOffset
            } else {
                // absolute numbering of pre/post synaptic cells
                srcid1 = srcid
                destid1 = destid
            }
            
	    if (pnm.gid_exists(srcid1)) { 
		mkgap(gjlist, srcid1, ggid+1, ggid, w)
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                gjconlist.prepend(edges)
	    }
            
	    if (pnm.gid_exists(destid1)) {
		mkgap(gjlist, destid1, ggid, ggid+1, w)
	    }
        }
    }
}


proc mknet() { strdef fname
    startsw()
    mkcells(cellTypes)  // create the cells
    mkcellstime = stopsw()
    startsw()
    connectcells(connectivityTypes,cellTypes)  // connect them together
    connectgjstime = stopsw()
    startsw()
    //connectgjs(gjTypes,cellTypes)  // creates the gap junctions
    connectgjstime = stopsw()
    sprint(fname, "./results/%s_%d.dat", modelName, pnm.myid)
    if (makegraph > 0) {
        graphout(fname,conlist)
    }
}


mknet(ncells)

// Configuration of artificial spiking cells

proc mkstim() { local i, k, nCellTypes, numCells, offset localobj stim, stimulationParameters, cellType, cellTypes
    
    strdef templateName, typeName
    
    datasetPath = $s1
    cellTypes = $o2
    nCellTypes = cellTypes.count()
    
    for k=0, nCellTypes-1 { 
        
        cellType = cellTypes.o(k)
        typeName = cellType.getPropertyString("typeName").s
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset = cellType.getPropertyScalar("offset")
        
        if (strcmp(templateName, "NetStim") == 0) {
            sprint (datafilePath, "%s/%s.dat", datasetPath, typeName)
            stimulationParameters = new Matrix()
            // Reads the stimulation parameters file and populates the
            // stimulationParameters matrix with the information
            loadStimulationParameters (stimulationParameters, datafilePath)

            for i=0, numCells-1 { 
                if (pnm.gid_exists(offset+i)) {
                    stim = pnm.pc.gid2obj(offset+i)
                    stim.noise  = stimulationParameters.x[i][0]
                    stim.number = stimulationParameters.x[i][1]
                    stim.start  = stimulationParameters.x[i][2]
                }
            }
        }
    }
}

mkstim(datasetPath, cellTypes, ncells)

/* Simulation control */

{cvode.active(use_cvode)}
{cvode.use_local_dt(use_local_dt)}
{cvode.cache_efficient(use_cache_efficient)}

{pnm.set_maxstep(10)}
{pnm.want_all_spikes()}
{pnm.pc.setup_transfer()}


stdinit()
startsw()
pnm.psolve(tstop)
runtime = stopsw()

/* Write simulation results */

strdef spikeout_fname
sprint(spikeout_fname, "./results/%s_spikeout_%d.dat", modelName, pnm.myid)
spikeout(spikeout_fname,pnm.spikevec,pnm.idvec)

comptime = pnm.pc.step_time
avgcomp  = pnm.pc.allreduce(comptime, 1)/pnm.pc.nhost
maxcomp  = pnm.pc.allreduce(comptime, 2)

if (pnm.myid == 0) {
    printf("Execution time summary for host 0:\n")
    printf("  created cells in %g seconds\n", mkcellstime)
    printf("  connected cells in %g seconds\n", connectcellstime)
    printf("  ran simulation in %g seconds\n", runtime)
    if (maxcomp > 0) {
        if (pnm.myid == 0) { printf("  load_balance = %g\n", avgcomp/maxcomp) }
        if (pnm.myid == 0) { printf("  exchange_time = %g\n",  runtime - maxcomp) }
    }
}

pnm.pc.runworker()
pnm.pc.done()

quit()
