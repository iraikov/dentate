{load_file("nrngui.hoc")}  // loads the gui and standard run libraries
{load_file("netparmpi.hoc")} // parallelnetmanager definitions

 // directories external to this project that contain additional templates and mechanisms
objref nil, externalPaths
strdef modelName, datasetPrefix, datasetName, datasetPath

// parameters must be the name of a file specified on the command line
// as follows: nrniv -c "strdef parameters" -c "parameters=\"parameters.hoc\""
{load_file(parameters)}

{cvode.active(use_cvode)}
{cvode.use_local_dt(use_local_dt)}
{cvode.cache_efficient(use_cache_efficient)}

{xopen("lib.hoc")}

// path to the dataset directory
sprint(datasetPath, "%s/%s", datasetPrefix, datasetName)

nrn_load_dll("mechanisms/x86_64/.libs/libnrnmech.so")

strdef path, mechanismsPath
// Load mechanisms from external location
if (!(externalPaths == nil)) {
    for i=0,externalPaths.count()-1 {
        path = externalPaths.o(i).s
        sprint(mechanismsPath, "%s/x86_64/.libs/libnrnmech.so", path)
        nrn_load_dll(mechanismsPath)
    }
}

// used to calculate model construction times and run time
mkcellstime = 0
connectcellstime = 0
connectgjstime = 0

// used for executing command strings
strdef cmd

// path for various datafiles (used for multiple files)
strdef datafilePath

// randomstream template
{load_file("./templates/ranstream.hoc")}


// used to keep track of artificial stimulus cells
objref stimTypes
stimTypes = new List()
objref ncstimlist

// reads the cell types file and populates celltypes with the information
sprint (datafilePath, "%s/stim.dat", datasetPath)
loadStimulationInfo (stimTypes, datafilePath, datasetPath)

if (verbose > 0) {
    printf ("%s: loaded stimulation info\n", modelName)
}

// list with cell type information
objref cellTypes
cellTypes = new List()

// reads the cell types file and populates celltypes with the information
sprint (datafilePath, "%s/celltypes.dat", datasetPath)
loadCellCategoryInfo (cellTypes, datafilePath, datasetPath)

if (verbose > 0) {
    printf ("%s: loaded cell info\n", modelName)
}

// used for synapse information
objref synapseTypes
synapseTypes = new List()
// reads the synapse types file and populates synapseTypes with the information
loadSynapseInfo (synapseTypes, datasetPath)

if (verbose > 0) {
    printf ("%s: loaded synapse info\n", modelName)
}

// total number of cells in the network
ncells = 0
maxindex = 0
strdef templatename
objref celltype, indices
for i=0, cellTypes.count()-1 { 
    celltype = cellTypes.o(i)
    if (celltype.hasProperty("indices")) {
       indices = celltype.getPropertyObject("indices")
       maxindex = indices.max()
       if (ncells < maxindex) {
          ncells = maxindex+1
       }
    } else {
       ncells = ncells + celltype.getPropertyScalar("numCells") + 1
    }
}
if (verbose > 0) {
    printf ("%s: ncells = %d\n", modelName, ncells)
}


// list with connectivity information
objref connectivityTypes
connectivityTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/connectivity.dat", datasetPath)
loadConnectivityInfo (connectivityTypes, datafilePath)
if (verbose > 0) {
    printf ("connectivityTypes.count = %d\n", connectivityTypes.count())
}

// list with gap junction information
objref gjTypes
gjTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/gapjunctions.dat", datasetPath)
loadGapJunctionInfo (gjTypes, datafilePath)

// pnm.cells is a list that holds all instances of network cells that
// exist on this host

// pnm.nclist holds all netcon instances that exist on this host

objref pnm

pnm = new ParallelNetManager(ncells)

ncells = 0
for i=0, cellTypes.count()-1 { 
    celltype = cellTypes.o(i)
    if (celltype.hasProperty("indices")) {
       indices = celltype.getPropertyObject("indices")
       for j = 0, indices.size()-1 {
          pnm.set_gid2node(indices.x[j], j % pnm.pc.nhost)
       }
       maxindex = indices.max()
       if (ncells < maxindex) {
          ncells = maxindex+1
       }
    } else {
       for j = ncells, ncells+celltype.getPropertyScalar("numCells")-1 {
          pnm.set_gid2node(j, j % pnm.pc.nhost)
       }
       ncells = ncells + celltype.getPropertyScalar("numCells") + 1
    }
}


// each noise generator picks a number every
// dt for the full time range, so stream
// sections must be at least this long to
// prevent overlap
noise_random_stream_offset_ = tstop/dt + 1	

// connectivity list local to the current mpi process
objref conlist
if (makegraph > 0) {
    conlist = new List()
}

// gap junction connectivity list local to the current mpi process
objref gjconlist
if (makegraph > 0) {
    gjconlist = new List()
}

// gap junction list local to the current mpi process
objref gjlist
gjlist = new List()

/* mkcells and connectcells create the cells and connect the cells */

// used for the creation of cells
objref cell, nc, syn

// helper function to create synapses
proc mksyn() { local i, dendnum, compnum localobj cell, riseTime, decayTime, erev, dend, comp, rs, dendindex, compindex strdef cellTypeName

    cell = $o1
    riseTime = $o2
    decayTime = $o3
    erev = $o4
    dend = $o5 
    comp = $o6
    rs = $o7
    cellTypeName = $s8
    
    for i = 0, cell.syns.count()-1 {

        dendindex = dend.o(i)
        compindex = comp.o(i)

        if (dendindex.is_nil) { continue }
        
        if (dendindex.is_object) {
            
            dendnum = rs.repick() % dendindex.l.o(i).n
            compnum = rs.repick() % compindex.l.o(i).n

            print "dendnum = ", dendnum, " compnum = ", compnum
            
            cell.dendrites[dendnum][compnum] {
                
	        syn = new Exp2Syn(0.5)
                syn.tau1 = riseTime.o(i).n
                syn.tau2 = decayTime.o(i).n
                syn.e = erev.o(i).n
    		cell.syns.o(i).append(syn)
                }

 	    } else if (dendindex.is_number) {
                
                dendnum = dendindex.n
                compnum = compindex.n

                print "cellType =", cellTypeName, " dendnum = ", dendnum, " compnum = ", compnum
                
                cell.dendrites[dendnum][compnum] {
	            syn = new Exp2Syn(0.5)
                    syn.tau1 = riseTime.o(i).n
                    syn.tau2 = decayTime.o(i).n
                    syn.e = erev.o(i).n
    		    cell.syns.o(i).append(syn)
                    }

 	        } else {
                    
                    cell.soma {
	                syn = new Exp2Syn(0.5)
                        syn.tau1 = riseTime.o(i).n
                        syn.tau2 = decayTime.o(i).n
                        syn.e = erev.o(i).n
    		        cell.syns.o(i).append(syn)

                    }
                }
                
            }
        }



// creates the cells and appends them to a list called cells
// argument is the number of cells to be created
proc mkcells() { local nCellTypes, numCells, i, j, p, gid, node, nodeSize, nodeNumber, treeHeight  localobj cellTypes, cellType, datadirIndex, indices, synProps, synRiseTime, synDecayTime, synErev, synDend, synComp, rs
    
    strdef templateName, typeName, datadir
    
    cellTypes = $o1
    nCellTypes = cellTypes.count()
    
    for k=0, nCellTypes-1 { 
        
        cellType = cellTypes.o(k)
        
        typeName = cellType.getPropertyString("typeName").s
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset   = cellType.getPropertyScalar("offset")

        print "typeName = ", typeName
        
        if (cellType.hasProperty("indices")) {
            indices = cellType.getPropertyObject("indices")
        } else {
            indices = new Vector()
            indices.resize(numCells)
            for i = 0, numCells-1 {
                indices.x[i] = i+offset
            }
        }
        
        synProps = getSynapseProperties(synapseTypes,typeName)
        synRiseTime = synProps.getPropertyObject("rise time")
        synDecayTime = synProps.getPropertyObject("decay time")
        synErev = synProps.getPropertyObject("reversal potential")
        synDend = synProps.getPropertyObject("dendrite")
        synComp = synProps.getPropertyObject("compartment")
        
        // used for choosing dendrite and compartment for synapses
        rs = new RandomStream(k)
        rs.r.discunif(0,3)
        
        find_template(externalPaths, templateName)
        // For cell templates that load their morphologies from
        // external files, set the maximum number of files per
        // directory to nodeSize, and calculate the maximum height
        // (or depth) of the directory tree necessary to store all
        // files for that cell type.
        nodeSize = 5000 
        if (numCells > nodeSize) {
            nodeNumber = int(numCells / nodeSize)
            treeHeight = int((log10(nodeNumber+1) / log10(2))+1)
            for i=0, numCells-1 { 
                datadir=""
                gid = indices.x(i)
                if (pnm.gid_exists(gid)) {
                    node=int(i/nodeSize)
                    for (j=treeHeight-1; j >= 0; j = j-1) {
                        p = 2^j
                        if (node >= p) {
                            node = node-p
                            sprint(datadir, "%s/1", datadir)
                        } else {
                            sprint(datadir, "%s/0", datadir)
                        }
                    }
                    sprint(cmd, "cell = new %s(%d, %d, \"%s/%s%s\")", templateName, i, noise_random_stream_offset_, datasetPath, typeName, datadir)
                    execute(cmd)
                    // TODO: Temporarily disabled making of synapses for GC cells
                    //mksyn(cell,synRiseTime,synDecayTime,synErev,synDend,synComp)
	            pnm.register_cell(gid, cell)
                    pnm.spike_record(gid)
                }
            }
        } else {
            for i=0, numCells-1 { 
                gid = indices.x(i)
                if (pnm.gid_exists(gid)) {
                    sprint(cmd, "cell = new %s(%d, %d, \"%s/%s/\")", templateName, i, noise_random_stream_offset_, datasetPath, typeName)
                    execute(cmd)
                    mksyn(cell,synRiseTime,synDecayTime,synErev,synDend,synComp,rs,typeName)
	            pnm.register_cell(gid, cell)
                    pnm.spike_record(gid)
                }
            }
        }
    }
}

// connects the cells
// appends the NetCon objects to nclist
proc connectcells() {local i, k, srcid, destid, srcid1, destid1, w, del, dist, velocity, ncid, wdType, order, presynapticSize, postsynapticSize, stimsrc localobj presynapticType, postsynapticType, cellTypes, connectivityType, connectivityTypes, nc, edges, m, f, stim, synType
    
    strdef connectivityPath, connectivityName, presynapticPopulation, postsynapticPopulation
    connectivityTypes = $o1
    cellTypes = $o2
    nConnectivityTypes = connectivityTypes.count()
    if (verbose > 0) {
       printf ("nConnectivityTypes = %d\n", nConnectivityTypes)
    }
    
    for k=0, nConnectivityTypes-1 { 
        connectivityType = connectivityTypes.o(k)
        order = connectivityType.getPropertyScalar("order")
        synType = connectivityType.getPropertyObject("synType")
        wdType = connectivityType.getPropertyScalar("wdType")
        connectivityName = connectivityType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("connectivityName = %s\n", connectivityName)
            printf ("wdType = %d\n", wdType)
        }
        presynapticPopulation = connectivityType.getPropertyString("presynapticPopulation").s
        presynapticType = cellTypes.o(findCellType(cellTypes,presynapticPopulation))
        presynapticSize = presynapticType.getPropertyScalar("numCells")
        presynapticOffset = presynapticType.getPropertyScalar("offset")
        postsynapticPopulation = connectivityType.getPropertyString("postsynapticPopulation").s
        postsynapticType = cellTypes.o(findCellType(cellTypes,postsynapticPopulation))
        postsynapticSize = postsynapticType.getPropertyScalar("numCells")
        postsynapticOffset = postsynapticType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("presynaptic population = %s\n", presynapticPopulation)
            printf ("presynaptic size = %d\n", presynapticSize)
            printf ("postsynaptic population = %s\n", postsynapticPopulation)
            printf ("postsynaptic size = %d\n", postsynapticSize)
        }
        if (strcmp(presynapticType.getPropertyString("templateName").s, "NetStim") == 0) {
            stimsrc = 1
            sprint(cmd, "ncstimlist = nc%slist", presynapticPopulation)
            execute(cmd)
        } else {
            stimsrc = 0
        }
        sprint(connectivityPath, "%s/%s.dat", datasetPath, connectivityName)
        m = new Matrix()
        f = new File(connectivityPath)
        f.ropen()
        m.scanf(f)
        f.close()
        if (wdType == 1) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                w = m.x[i][2]
                del = m.x[i][3]
	        ncid = nc_appendsyn(pnm,srcid1, destid1, synType, w, del)
                if (verbose > 0) {
                   printf("host %d: connection src = %d dest = %d w = %g del = %g\n", pnm.myid, srcid1, destid1, w, del)
                }
                nc = pnm.nclist.o(ncid)
		if (makegraph > 0) {
                  edges = new Vector(2)
                  edges.x[0] = srcid1
                  edges.x[1] = destid1
                  conlist.prepend(edges)
		}
            }
            m.resize(1,1)
        } else if (wdType == 2) {
            w = connectivityType.getPropertyScalar("standardWeight")
            velocity = connectivityType.getPropertyScalar("standardVelocity")
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                dist = m.x[i][2] + m.x[i][3]
                del = (dist / velocity) + 1.0
	        ncid = nc_appendsyn(pnm, srcid1, destid1, synType, w, del)
                if (verbose > 0) {
                   printf("host %d: connection src = %d dest = %d w = %g del = %g\n", pnm.myid, srcid1, destid1, w, del)
                }
		if (makegraph > 0) {
                  edges = new Vector(2)
                  edges.x[0] = srcid1
                  edges.x[1] = destid1
                  conlist.prepend(edges)
		}
            }
            m.resize(1,1)
        }
    }
}

proc mkgap() { local gid, sgid, dgid, w localobj cell, gj, gjlist
    
    gjlist = $o1
    gid    = $2
    branch = $3
    sec    = $4
    dgid   = $5
    sgid   = $6
    w      = $7
    
    cell = pnm.pc.gid2cell(gid)
    
    cell.dendrites[branch][sec] { 
        gj = new ggap(0.5) 
        pnm.pc.target_var(gj, &gj.vgap, dgid)
        pnm.pc.source_var(&cell.dendrites[branch][sec].v(0.5), sgid)
    }
    
    gjlist.append(gj)
    gj.g = w
    
    if (verbose > 0) {
        printf ("host %d: gap junction: gid = %d branch = %d sec = %d coupling = %g sgid = %d dgid = %d\n", pnm.myid, gid, branch, sec, w, sgid, dgid)
    }
    
}

// creates the gap junctions between cells
proc connectgjs() {local i, k, w, ggid, srcid, destid, srcid1, destid1, srcbranch, destbranch, srcsec, destsec, order, srcSize, destSize localobj srcType, destType, cellTypes, gjType, gjTypes, edges, m, f
    
    strdef gjPath, gjName, srcPopulation, destPopulation
    gjTypes = $o1
    cellTypes = $o2
    nGJTypes = gjTypes.count()
    ggid = 2*ncells
    
    for k=0, nGJTypes-1 { 
        gjType = gjTypes.o(k)
        order  = gjType.getPropertyScalar("order")
        gjName = gjType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("gjName = %s\n", gjName)
        }
        srcPopulation  = gjType.getPropertyString("srcPopulation").s
        destPopulation = gjType.getPropertyString("destPopulation").s
        if (verbose > 0) {
            printf ("src population = %s\n", srcPopulation)
            printf ("dest population = %s\n", destPopulation)
        }
        srcType    = cellTypes.o(findCellType(cellTypes,srcPopulation))
        destType   = cellTypes.o(findCellType(cellTypes,destPopulation))
        srcSize    = srcType.getPropertyScalar("numCells")
        destSize   = destType.getPropertyScalar("numCells")
        srcOffset  = srcType.getPropertyScalar("offset")
        destOffset = destType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("src size = %d\n", srcSize)
            printf ("dest size = %d\n", destSize)
        }
        sprint(gjPath, "%s/%s.dat", datasetPath, gjName)
        m = new Matrix()
        f = new File(gjPath)
        f.ropen()
        m.scanf(f)
        f.close()
        for i=0, m.nrow-1 {
            srcid = m.x[i][0]
            destid = m.x[i][1]
            srcbranch = m.x[i][2]
            srcsec = m.x[i][3]
            destbranch = m.x[i][4]
            destsec = m.x[i][5]
            w = m.x[i][6]
            if (order == 0) {
                // relative numbering of pre/post synaptic cells -- add the respective offsets
                assert (srcid < srcSize, "source cell id is greater than the size of the src population")
                assert (destid < destSize, "destination cell id is greater than the size of the dest population")
                srcid1 = srcid + srcOffset
                destid1 = destid + destOffset
            } else {
                // absolute numbering of pre/post synaptic cells
                srcid1 = srcid
                destid1 = destid
            }

            
	    if (pnm.gid_exists(srcid1)) { 
		mkgap(gjlist, srcid1, srcbranch, srcsec, ggid+1, ggid, w)
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                gjconlist.prepend(edges)
	    }
            
	    if (pnm.gid_exists(destid1)) {
		mkgap(gjlist, destid1, destbranch, destsec, ggid, ggid+1, w)
	    }
            ggid = ggid+2
        }
    }
}


proc mknet() { strdef fname
    startsw()
    mkcells(cellTypes)  // create the cells
    mkcellstime = stopsw()
    printf ("*** Cells created\n")
    startsw()
    connectcells(connectivityTypes,cellTypes)  // connect them together
    connectcellstime = stopsw()
    printf ("*** Synaptic connections created\n")
    startsw()
    connectgjs(gjTypes,cellTypes)  // creates the gap junctions
    connectgjstime = stopsw()
    printf ("*** Gap junctions created\n")
    sprint(fname, "%s/%s_%d.dat", resultsPath, modelName, pnm.myid)
    if (makegraph > 0) {
        graphout(fname,conlist)
    }
}


mknet(ncells)

// Configuration of artificial spiking cells

proc mkstim() { local i, k, nCellTypes, nStimTypes, gid, weight, noise, number, start localobj stim, stimulationParameters, cellType, cellTypes, stimType, stimTypes
    
    strdef templateName, typeName
    
    datasetPath = $s1
    cellTypes = $o2
    nCellTypes = cellTypes.count()
    stimTypes = $o3
    nStimTypes = stimTypes.count()
    
    // Used to keep track of artificial stimulus cells
    typeName = "stim"
    sprint (cmd, "objref %slist, nc%slist", typeName, typeName)
    execute(cmd)
    sprint (cmd, "%slist = new List()", typeName)
    execute(cmd)
    sprint (cmd, "nc%slist = new List()", typeName)
    execute(cmd)
    
    stimgid = maxindex+1
    
    for i=0, numStimTypes-1 { 
        
        stimType = stimTypes.o(i)
        
        indices = stimType.getPropertyObject("indices")
        weight = stimType.getPropertyScalar("weight")
        noise = stimType.getPropertyScalar("noise")
        number = stimType.getPropertyScalar("number")
        start = stimType.getPropertyScalar("start")
        
        for j=0, indices.count()-1 {
            
            gid = indices.x(j)
            if (pnm.gid_exists(gid)) {
                stim = new NetStim(0.0)
                stim.noise = noise
                stim.number = number
                stim.start = start
                pnm.register_cell(stimgid, stim)
                nc = pnm.pc.gid_connect(stimgid, pnm.pc.gid2obj(gid).syn_stim)
                nc.weight = weight
                nc.delay = 0.1
                ncstimlist.append(nc)
                
	        if (makegraph > 0) {
                    edges = new Vector(2)
                    edges.x[0] = stimgid
                    edges.x[1] = gid
                    conlist.prepend(edges)
	        }	
                
            }
        }
    }
}

mkstim(datasetPath, cellTypes, stimTypes)

printf ("*** Stimulus sources initialized\n")

/* Simulation control */


{pnm.pc.setup_transfer()}
{pnm.pc.set_maxstep(10)}

print "dt = ", dt

objref fi
fi = new FInitializeHandler("simstatus()")

stdinit()

printf ("*** Initialization completed\n")

pnm.psolve(tstop)

printf ("*** Simulation completed\n")

/* Write simulation results */

strdef spikeout_fname
sprint(spikeout_fname, "%s/%s_spikeout_%d.dat", resultsPath, modelName, pnm.myid)
spikeout(spikeout_fname,pnm.spikevec,pnm.idvec)

comptime = pnm.pc.step_time
avgcomp  = pnm.pc.allreduce(comptime, 1)/pnm.pc.nhost
maxcomp  = pnm.pc.allreduce(comptime, 2)

if (pnm.myid == 0) {
    printf("Execution time summary for host 0:\n")
    printf("  created cells in %g seconds\n", mkcellstime)
    printf("  connected cells in %g seconds\n", connectcellstime)
    printf("  created gap junctions in %g seconds\n", connectgjstime)
    printf("  ran simulation in %g seconds\n", comptime)
    if (maxcomp > 0) {
        if (pnm.myid == 0) { printf("  load_balance = %g\n", avgcomp/maxcomp) }
    }
}

printf ("*** Simulation results written\n")

pnm.pc.runworker()
pnm.pc.done()

quit()
