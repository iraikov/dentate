{load_file("nrngui.hoc")}  // Loads the GUI and standard run libraries
{load_file("netparmpi.hoc")} // ParallelNetManager definitions

{xopen("lib.hoc")}
{load_file("parameters.hoc")}

nrn_load_dll("mechanisms/x86_64/.libs/libnrnmech.so")

// Used to calculate model construction times and run time
mkcellstime = 0
connectcellstime = 0
runtime = 0

// Used for executing command strings
strdef cmd

// Path to the dataset directory
strdef datasetPath
sprint(datasetPath, "./datasets/%s", datasetName)

// Path for various datafiles (used for multiple files)
strdef datafilePath

// RandomStream template
{load_file("./templates/ranstream.hoc")}

// List with cell type information
objref cellTypes
cellTypes = new List()

// Reads the cell types file and populates cellTypes with the information
sprint (datafilePath, "%s/celltypes.dat", datasetPath)
loadCellCategoryInfo (cellTypes, datafilePath)

// Total number of cells in the network
ncells = 0
for i=0, cellTypes.count()-1 {
    ncells = ncells + cellTypes.o(i).getPropertyScalar("numCells")
}
if (verbose > 0) {
    printf ("%s: ncells = %d\n", modelName, ncells)
}


// List with connectivity information
objref connectivityTypes
connectivityTypes = new List()

// Reads the connectivity types file and populates connectivityTypes with the information
sprint (datafilePath, "%s/connectivity.dat", datasetPath)
loadConnectivityInfo (connectivityTypes, datafilePath)

// pnm.cells is a list that holds all instances of network cells that
// exist on this host

// pnm.nclist holds all NetCon instances that exist on this host

objref pnm

pnm = new ParallelNetManager(ncells)

pnm.round_robin()

// Each noise generator picks a number every
// dt for the full time range, so stream
// sections must be at least this long to
// prevent overlap
noise_random_stream_offset_ = tstop/dt + 1	

// connectivity list local to the current MPI process
objref conlist
if (makegraph > 0) {
    conlist = new List()
}

/* mkcells and connectcells create the cells and connect the cells */

// used for the creation of cells
objref cell

// creates the cells and appends them to a List called cells
// argument is the number of cells to be created
proc mkcells() { local nCellTypes, numCells, i, k, bot  localobj cellTypes, cellType strdef templateName
    
    cellTypes = $o1
    nCellTypes = cellTypes.count()
    
    bot=0
    i=0
    for k=0, nCellTypes-1 { 
        cellType = cellTypes.o(k)
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        if (strcmp(templateName, "NetStim") != 0) {
            sprint(cmd, "xopen(\"./templates/%s.hoc\")", templateName)
        }
        execute(cmd)
        for i=0, numCells-1 { 
            if (pnm.gid_exists(bot+i)) {
                sprint(cmd, "cell = new %s()", templateName)
                execute(cmd)
	        pnm.register_cell(bot+i, cell)
            }
        }
        bot = bot + numCells
    }
}


// connects the cells
// appends the NetCon objects to nclist
proc connectcells() {local i, k, srcid, destid, w, del, dist, velocity, ncid, synIndex, wdType  localobj connectivityType, nc, edges, m, f
    
    strdef connectivityPath, connectivityName
    connectivityTypes = $o1
    nConnectivityTypes = connectivityTypes.count()
    
    for k=0, nConnectivityTypes-1 { 
        connectivityType = connectivityTypes.o(k)
        synIndex = connectivityType.getPropertyScalar("synIndex")
        wdType = connectivityType.getPropertyScalar("wdType")
        connectivityName = connectivityType.getPropertyString("name").s
        sprint(connectivityPath, "%s/%s.dat", datasetPath, connectivityName)
        m = new Matrix()
        f = new File(connectivityPath)
        f.ropen()
        m.scanf(f)
        f.close()
        if (wdType == 1) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (!pnm.gid_exists(destid)) { continue }
                w = m.x[i][2]
                del = m.x[i][3]
                // The third argument is synapse index or -1 for point processes
	        ncid = pnm.nc_append(srcid, destid, synIndex, w, del)
                edges = new Vector(2)
                edges.x[0] = srcid
                edges.x[1] = destid
                conlist.prepend(edges)
            }
        } else if (wdType == 2) {
            w = connectivityType.getPropertyScalar("standardWeight")
            velocity = connectivityType.getPropertyScalar("standardVelocity")
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (!pnm.gid_exists(destid)) { continue }
                dist = m.x[i][2] + m.x[i][3]
                del = dist / velocity
                // The third argument is synapse index or -1 for point processes
	        ncid = pnm.nc_append(srcid, destid, synIndex, w, del)
                edges = new Vector(2)
                edges.x[0] = srcid
                edges.x[1] = destid
                conlist.prepend(edges)
            }
        }
    }
}

proc mknet() { strdef fname
    startsw()
    mkcells(cellTypes)  // create the cells
    mkcellstime = stopsw()
    startsw()
    connectcells(connectivityTypes)  // connect them together
    connectcellstime = stopsw()
    sprint(fname, "./results/%s_%d.dat", modelName, pnm.myid)
    if (makegraph > 0) {
        graphout(fname,conlist)
    }
}


mknet(ncells)

// Configuration of artificial spiking cells

proc mkstim() { local i, nCellTypes, numCells localobj stim, stimulationParameters, cellType
    
    stimulationParameters = new Matrix()
    // Reads the stimulation parameters file and populates the
    // stimulationParameters matrix with the information
    loadStimulationParameters (stimulationParameters, $s1)
    
    nCellTypes = cellTypes.count()
    
    bot = 0
    for k = 0, nCellTypes-1 { 
        cellType = cellTypes.o(k)
        numCells = cellType.getPropertyScalar("numCells")
        if (strcmp(cellType.getPropertyString("templateName").s, "NetStim") == 0) {
            for i = 0, numCells-1 {
                if (pnm.gid_exists(i)) {
                    stim = pnm.pc.gid2cell(bot+i)
                    stim.noise  = stimulationParameters.x[i][0]
                    stim.number = stimulationParameters.x[i][1]
                    stim.start  = stimulationParameters.x[i][2]
                }
            }
            break
            
        }
        bot = bot + numCells
    }
    
}

sprint (datafilePath, "%s/stimulation.dat", datasetPath)
mkstim(datafilePath)

/* Simulation control */

pnm.set_maxstep(100)
pnm.want_all_spikes()

cvode.active(1)
stdinit()
startsw()
pnm.psolve(tstop)
runtime = stopsw()

/* Write simulation results */

strdef spikeout_fname
sprint(spikeout_fname, "./results/%s_spikeout_%d.dat", modelName, pnm.myid)
spikeout(spikeout_fname,pnm.spikevec,pnm.idvec)

comptime = pnm.pc.step_time
avgcomp  = pnm.pc.allreduce(comptime, 1)/pnm.pc.nhost
maxcomp  = pnm.pc.allreduce(comptime, 2)

if (pnm.myid == 0) {
    printf("Execution time summary for host 0:\n")
    printf("  created cells in %g seconds\n", mkcellstime)
    printf("  connected cells in %g seconds\n", connectcellstime)
    printf("  ran simulation in %g seconds\n", runtime)
    if (maxcomp > 0) {
        if (pnm.myid == 0) { printf("  load_balance = %g\n", avgcomp/maxcomp) }
        if (pnm.myid == 0) { printf("  exchange_time = %g\n",  runtime - maxcomp) }
    }
}

pnm.pc.runworker()
pnm.pc.done()

quit()
