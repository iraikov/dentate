{load_file("nrngui.hoc")}  // loads the gui and standard run libraries
{load_file("netparmpi.hoc")} // parallelnetmanager definitions

{xopen("lib.hoc")}
{load_file("parameters.hoc")}

nrn_load_dll("mechanisms/x86_64/.libs/libnrnmech.so")

strdef path, mechanismsPath
// Load mechanisms from external location
for i =0,exernalPaths.count()-1 {
    path = externalPaths.o(i).s
    sprint(mechanismsPath, "%s/x86_64/.libs/libnrnmech.so", path)
    nrn_load_dll(path)
}

// used to calculate model construction times and run time
mkcellstime = 0
connectcellstime = 0
runtime = 0


// used for executing command strings
strdef cmd

// path to the dataset directory
strdef datasetPath
sprint(datasetPath, "./datasets/%s", datasetName)

// path for various datafiles (used for multiple files)
strdef datafilePath

// randomstream template
{load_file("./templates/ranstream.hoc")}

// list with cell type information
objref cellTypes
cellTypes = new List()

// used to keep track of artificial stimulus cells
objref ncstimlist

// reads the cell types file and populates celltypes with the information
sprint (datafilePath, "%s/celltypes.dat", datasetPath)
loadCellCategoryInfo (cellTypes, datafilePath)

// total number of cells in the network
ncells = 0
strdef templatename
objref celltype
for i=0, cellTypes.count()-1 { 
    celltype = cellTypes.o(i)
    ncells = ncells + celltype.getPropertyScalar("numCells")
}
if (verbose > 0) {
    printf ("%s: ncells = %d\n", modelName, ncells)
}


// list with connectivity information
objref connectivityTypes
connectivityTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/connectivity.dat", datasetPath)
loadConnectivityInfo (connectivityTypes, datafilePath)

// pnm.cells is a list that holds all instances of network cells that
// exist on this host

// pnm.nclist holds all netcon instances that exist on this host

objref pnm

pnm = new ParallelNetManager(ncells)

pnm.round_robin()

// each noise generator picks a number every
// dt for the full time range, so stream
// sections must be at least this long to
// prevent overlap
noise_random_stream_offset_ = tstop/dt + 1	

// connectivity list local to the current mpi process
objref conlist
if (makegraph > 0) {
    conlist = new List()
}

/* mkcells and connectcells create the cells and connect the cells */

// used for the creation of cells
objref cell, nc

// creates the cells and appends them to a list called cells
// argument is the number of cells to be created
proc mkcells() { local nCellTypes, numCells, i, k  localobj cellTypes, cellType strdef templateName, typeName
    
    cellTypes = $o1
    nCellTypes = cellTypes.count()
    
    for k=0, nCellTypes-1 { 
        cellType = cellTypes.o(k)
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset = cellType.getPropertyScalar("offset")
        if (strcmp(templateName, "NetStim") != 0) {
            find_template(externalPaths, templateName)
            for i=0, numCells-1 { 
                if (pnm.gid_exists(offset+i)) {
                    sprint(cmd, "cell = new %s(%d, %d, \"./datasets/%s\")", 
                           offset+i, randomStreamOffset, datasetName, templateName)
                    execute(cmd)
	            pnm.register_cell(offset+i, cell)
                }
            }
        } else {
            // Used to keep track of artificial stimulus cells
            typeName = cellType.getPropertyString("typeName").s
            sprint (cmd, "objref %slist, nc%slist", typeName, typeName)
            execute(cmd)
            sprint (cmd, "%slist = new List()", typeName)
            execute(cmd)
            sprint (cmd, "nc%slist = new List()", typeName)
            execute(cmd)
            for i=0, numCells-1 { 
                if (pnm.gid_exists(offset+i)) {
                    cell = new NetStim(0.0)
                    pnm.register_cell(offset+i, cell)
                }
            }
        }
    }
}

// connects the cells
// appends the NetCon objects to nclist
proc connectcells() {local i, k, srcid, destid, srcid1, destid1, w, del, dist, velocity, ncid, synIndex, wdType, order, presynapticSize, postsynapticSize, stimsrc localobj presynapticType, postsynapticType, cellTypes, connectivityType, connectivityTypes, nc, edges, m, f, stim
    
    strdef connectivityPath, connectivityName, presynapticPopulation, postsynapticPopulation
    connectivityTypes = $o1
    cellTypes = $o2
    nConnectivityTypes = connectivityTypes.count()
    
    for k=0, nConnectivityTypes-1 { 
        connectivityType = connectivityTypes.o(k)
        order = connectivityType.getPropertyScalar("order")
        synIndex = connectivityType.getPropertyScalar("synIndex")
        wdType = connectivityType.getPropertyScalar("wdType")
        connectivityName = connectivityType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("connectivityName = %s\n", connectivityName)
        }
        presynapticPopulation = connectivityType.getPropertyString("presynapticPopulation").s
        postsynapticPopulation = connectivityType.getPropertyString("postsynapticPopulation").s
        presynapticType = cellTypes.o(findCellType(cellTypes,presynapticPopulation))
        postsynapticType = cellTypes.o(findCellType(cellTypes,postsynapticPopulation))
        presynapticSize = presynapticType.getPropertyScalar("numCells")
        postsynapticSize = postsynapticType.getPropertyScalar("numCells")
        presynapticOffset = presynapticType.getPropertyScalar("offset")
        postsynapticOffset = postsynapticType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("presynaptic population = %s\n", presynapticPopulation)
            printf ("presynaptic size = %d\n", presynapticSize)
            printf ("postsynaptic population = %s\n", postsynapticPopulation)
            printf ("postsynaptic size = %d\n", postsynapticSize)
        }
        if (strcmp(presynapticType.getPropertyString("templateName").s, "NetStim") == 0) {
            stimsrc = 1
            sprint(cmd, "ncstimlist = nc%slist", presynapticPopulation)
            execute(cmd)
        } else {
            stimsrc = 0
        }
        sprint(connectivityPath, "%s/%s.dat", datasetPath, connectivityName)
        m = new Matrix()
        f = new File(connectivityPath)
        f.ropen()
        m.scanf(f)
        f.close()
        if ((stimsrc == 1) && (wdType == 1)) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                nc = pnm.pc.gid_connect(srcid1, pnm.pc.gid2obj(destid1).synlist.object(synIndex))
                w = m.x[i][2]
                del = m.x[i][3]
                nc.weight = w
                nc.delay = del
                ncstimlist.append(nc)
                if (verbose > 0) {
                    printf ("artificial stimulus: srcid = %d destid = %d weight = %g delay = %g\n", srcid1, destid1, nc.weight, nc.delay)
                    print "postsynaptic cell = ", pnm.pc.gid2obj(destid)
                }
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                conlist.prepend(edges)
            }
        } else if (wdType == 1) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                w = m.x[i][2]
                del = m.x[i][3]
                // The third argument is synapse index or -1 for point processes
	        ncid = pnm.nc_append(srcid1, destid1, synIndex, w, del)
                nc = pnm.nclist.o(ncid)
                if (verbose > 0) {
                    printf ("connection: srcid = %d destid = %d weight = %g delay = %g\n", srcid1, destid1, nc.weight, nc.delay)
                }
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                conlist.prepend(edges)
            }
        } else if (wdType == 2) {
            w = connectivityType.getPropertyScalar("standardWeight")
            velocity = connectivityType.getPropertyScalar("standardVelocity")
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                dist = m.x[i][2] + m.x[i][3]
                del = dist / velocity
                // The third argument is synapse index or -1 for point processes
	        ncid = pnm.nc_append(srcid1, destid1, synIndex, w, del)
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                conlist.prepend(edges)
            }
        }
    }
}

proc mknet() { strdef fname
    startsw()
    mkcells(cellTypes)  // create the cells
    mkcellstime = stopsw()
    startsw()
    connectcells(connectivityTypes,cellTypes)  // connect them together
    connectcellstime = stopsw()
    sprint(fname, "./results/%s_%d.dat", modelName, pnm.myid)
    if (makegraph > 0) {
        graphout(fname,conlist)
    }
}


mknet(ncells)

// Configuration of artificial spiking cells

proc mkstim() { local i, k, nCellTypes, numCells, offset localobj stim, stimulationParameters, cellType, cellTypes
    
    strdef templateName, typeName
    
    datasetPath = $s1
    cellTypes = $o2
    nCellTypes = cellTypes.count()
    
    for k=0, nCellTypes-1 { 
        
        cellType = cellTypes.o(k)
        typeName = cellType.getPropertyString("typeName").s
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset = cellType.getPropertyScalar("offset")
        
        if (strcmp(templateName, "NetStim") == 0) {
            sprint (datafilePath, "%s/%s.dat", datasetPath, typeName)
            stimulationParameters = new Matrix()
            // Reads the stimulation parameters file and populates the
            // stimulationParameters matrix with the information
            loadStimulationParameters (stimulationParameters, datafilePath)

            for i=0, numCells-1 { 
                if (pnm.gid_exists(offset+i)) {
                    stim = pnm.pc.gid2obj(offset+i)
                    stim.noise  = stimulationParameters.x[i][0]
                    stim.number = stimulationParameters.x[i][1]
                    stim.start  = stimulationParameters.x[i][2]
                }
            }
        }
    }
}

mkstim(datasetPath, cellTypes, ncells)

/* Simulation control */

{cvode.active(use_cvode)}
{cvode.use_local_dt(use_local_dt)}
{cvode.cache_efficient(use_cache_efficient)}

pnm.set_maxstep(10)
pnm.want_all_spikes()

stdinit()
startsw()
pnm.psolve(tstop)
runtime = stopsw()

/* Write simulation results */

strdef spikeout_fname
sprint(spikeout_fname, "./results/%s_spikeout_%d.dat", modelName, pnm.myid)
spikeout(spikeout_fname,pnm.spikevec,pnm.idvec)

comptime = pnm.pc.step_time
avgcomp  = pnm.pc.allreduce(comptime, 1)/pnm.pc.nhost
maxcomp  = pnm.pc.allreduce(comptime, 2)

if (pnm.myid == 0) {
    printf("Execution time summary for host 0:\n")
    printf("  created cells in %g seconds\n", mkcellstime)
    printf("  connected cells in %g seconds\n", connectcellstime)
    printf("  ran simulation in %g seconds\n", runtime)
    if (maxcomp > 0) {
        if (pnm.myid == 0) { printf("  load_balance = %g\n", avgcomp/maxcomp) }
        if (pnm.myid == 0) { printf("  exchange_time = %g\n",  runtime - maxcomp) }
    }
}

pnm.pc.runworker()
pnm.pc.done()

quit()
