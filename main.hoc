{load_file("nrngui.hoc")}  // loads the gui and standard run libraries
{load_file("netparmpi.hoc")} // parallelnetmanager definitions

 // directories external to this project that contain additional templates and mechanisms
objref nil, externalPaths
strdef modelName, datasetPrefix, datasetName, datasetPath

// parameters must be the name of a file specified on the command line
// as follows: nrniv -c "strdef parameters" -c "parameters=\"parameters.hoc\""
{load_file(parameters)}

{cvode.active(use_cvode)}
{cvode.use_local_dt(use_local_dt)}
{cvode.cache_efficient(use_cache_efficient)}

{xopen("lib.hoc")}

// path to the dataset directory
sprint(datasetPath, "%s/%s", datasetPrefix, datasetName)

nrn_load_dll("mechanisms/x86_64/.libs/libnrnmech.so")

strdef path, mechanismsPath
// Load mechanisms from external location
if (!(externalPaths == nil)) {
    for i=0,externalPaths.count()-1 {
        path = externalPaths.o(i).s
        sprint(mechanismsPath, "%s/x86_64/.libs/libnrnmech.so", path)
        nrn_load_dll(mechanismsPath)
    }
}

// used to calculate model construction times and run time
mkcellstime = 0
connectcellstime = 0
connectgjstime = 0

// used for executing command strings
strdef cmd

// path for various datafiles (used for multiple files)
strdef datafilePath

// randomstream template
{load_file("./templates/ranstream.hoc")}

// list with cell type information
objref cellTypes
cellTypes = new List()

// used to keep track of artificial stimulus cells
objref ncstimlist

// reads the cell types file and populates celltypes with the information
sprint (datafilePath, "%s/celltypes.dat", datasetPath)
loadCellCategoryInfo (cellTypes, datafilePath, datasetPath)

// used for synapse information
objref synapseTypes
synapseTypes = new List()
// reads the synapse types file and populates synapseTypes with the information
loadSynapseInfo (synapseTypes, datasetPath)

// total number of cells in the network
ncells = 0
maxindex = 0
strdef templatename
objref celltype, indices
for i=0, cellTypes.count()-1 { 
    celltype = cellTypes.o(i)
    if (celltype.hasProperty("indices")) {
       indices = celltype.getPropertyObject("indices")
       maxindex = indices.max()
       if (ncells < maxindex) {
          ncells = maxindex+1
       }
    } else {
       ncells = ncells + celltype.getPropertyScalar("numCells") + 1
    }
}
if (verbose > 0) {
    printf ("%s: ncells = %d\n", modelName, ncells)
}


// list with connectivity information
objref connectivityTypes
connectivityTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/connectivity.dat", datasetPath)
loadConnectivityInfo (connectivityTypes, datafilePath)
if (verbose > 0) {
    printf ("connectivityTypes.count = %d\n", connectivityTypes.count())
}

// list with gap junction information
objref gjTypes
gjTypes = new List()

// reads the connectivity types file and populates connectivitytypes with the information
sprint (datafilePath, "%s/gapjunctions.dat", datasetPath)
loadGapJunctionInfo (gjTypes, datafilePath)

// pnm.cells is a list that holds all instances of network cells that
// exist on this host

// pnm.nclist holds all netcon instances that exist on this host

objref pnm

pnm = new ParallelNetManager(ncells)

ncells = 0
for i=0, cellTypes.count()-1 { 
    celltype = cellTypes.o(i)
    if (celltype.hasProperty("indices")) {
       indices = celltype.getPropertyObject("indices")
       for j = 0, indices.size()-1 {
          pnm.set_gid2node(indices.x[j], j % pnm.pc.nhost)
       }
       maxindex = indices.max()
       if (ncells < maxindex) {
          ncells = maxindex+1
       }
    } else {
       for j = ncells, ncells+celltype.getPropertyScalar("numCells")-1 {
          pnm.set_gid2node(j, j % pnm.pc.nhost)
       }
       ncells = ncells + celltype.getPropertyScalar("numCells") + 1
    }
}


// each noise generator picks a number every
// dt for the full time range, so stream
// sections must be at least this long to
// prevent overlap
noise_random_stream_offset_ = tstop/dt + 1	

// connectivity list local to the current mpi process
objref conlist
if (makegraph > 0) {
    conlist = new List()
}

// gap junction connectivity list local to the current mpi process
objref gjconlist
if (makegraph > 0) {
    gjconlist = new List()
}

// gap junction list local to the current mpi process
objref gjlist
gjlist = new List()

/* mkcells and connectcells create the cells and connect the cells */

// used for the creation of cells
objref cell, nc, syn

// helper function to create synapses
proc mksyn() { local i, dendindex, compindex localobjccell, riseTime, decayTime, erev, dend, comp, nil

    cell = $o1
    riseTime = $o2
    decayTime = $o3
    erev = $o4
    dend = $o5 
    comp = $o6

    for i = 0, syns.count()-1 {

        dendindex = dend.o(i)
        compindex = comp.o(i)

        if (dendindex == nil) { continue }

        if (dendindex.is_number) {
          cell.dendrites[dendindex.n][compindex.n] {
	        syn = new ExpSyn(0.5)
                syn.tau1 = riseTime.o(i).n
                syn.tau2 = decayTime.o(i).n
                syn.e = erev.o(i).n
    		syns.o(i).append(syn)
 	} else {
          cell.soma {
	        syn = new ExpSyn(0.5)
                syn.tau1 = riseTime.o(i).n
                syn.tau2 = decayTime.o(i).n
                syn.e = erev.o(i).n
    		syns.o(i).append(syn)
        }
    }

}


// creates the cells and appends them to a list called cells
// argument is the number of cells to be created
proc mkcells() { local nCellTypes, numCells, i, j, p, gid, node, nodeSize, nodeNumber, treeHeight  localobj cellTypes, cellType, datadirIndex, indices, synProps, synRiseTime, synDecayTime, synErev, synDend, synComp
    
    strdef templateName, typeName, datadir
    
    cellTypes = $o1
    nCellTypes = cellTypes.count()
    
    
    for k=0, nCellTypes-1 { 
        cellType = cellTypes.o(k)
        
        typeName = cellType.getPropertyString("typeName").s
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset   = cellType.getPropertyScalar("offset")
        
        if (cellType.hasProperty("indices")) {
            indices = cellType.getPropertyObject("indices")
        } else {
            indices = new Vector()
            indices.resize(numCells)
            for i = 0, numCells-1 {
                indices.x[i] = i+offset
            }
        }
        
        synProps = getSynapseProperties(synapseTypes,typeName)
        synRiseTime = synProps.getPropertyObject("rise time")
        synDecayTime = synProps.getPropertyObject("decay time")
        synErev = synProps.getPropertyObject("reversal potential")
        synDend = synProps.getPropertyObject("dendrite")
        synComp = synProps.getPropertyObject("compartment")
        
        if (strcmp(templateName, "NetStim") != 0) {
            find_template(externalPaths, templateName)
            // For cell templates that load their morphologies from
            // external files, set the maximum number of files per
            // directory to nodeSize, and calculate the maximum height
            // (or depth) of the directory tree necessary to store all
            // files for that cell type.
            nodeSize = 5000 
            if (numCells > nodeSize) {
                nodeNumber = int(numCells / nodeSize)
                treeHeight = int((log10(nodeNumber+1) / log10(2))+1)
                for i=0, numCells-1 { 
                    datadir=""
                    gid = indices.x(i)
                    if (pnm.gid_exists(gid)) {
                        node=int(i/nodeSize)
                        for (j=treeHeight-1; j >= 0; j = j-1) {
                            p = 2^j
                            if (node >= p) {
                                node = node-p
                                sprint(datadir, "%s/1", datadir)
                            } else {
                                sprint(datadir, "%s/0", datadir)
                            }
                        }
                        sprint(cmd, "cell = new %s(%d, %d, \"%s/%s%s\")", templateName, i, noise_random_stream_offset_, datasetPath, typeName, datadir)
                        execute(cmd)
                        mksyn(cell,synRiseTime,synDecayTime,synErev,synDend,synComp)
	                pnm.register_cell(gid, cell)
                        pnm.spike_record(gid)
                    }
                }
            } else {
                for i=0, numCells-1 { 
                    gid = indices.x(i)
                    if (pnm.gid_exists(gid)) {
                        sprint(cmd, "cell = new %s(%d, %d, \"%s/%s/\")", templateName, i, noise_random_stream_offset_, datasetPath, typeName)
                        execute(cmd)
                        mksyn(cell,synRiseTime,synDecayTime,synErev,synDend,synComp)
	                pnm.register_cell(gid, cell)
                        pnm.spike_record(gid)
                    }
                }
            }
        } else {
            // Used to keep track of artificial stimulus cells
            typeName = cellType.getPropertyString("typeName").s
            sprint (cmd, "objref %slist, nc%slist", typeName, typeName)
            execute(cmd)
            sprint (cmd, "%slist = new List()", typeName)
            execute(cmd)
            sprint (cmd, "nc%slist = new List()", typeName)
            execute(cmd)
            for i=0, numCells-1 { 
                gid = indices.x(i)
                if (pnm.gid_exists(gid)) {
                    cell = new NetStim(0.0)
                    pnm.register_cell(gid, cell)
                }
            }
        }
    }
}

// connects the cells
// appends the NetCon objects to nclist
proc connectcells() {local i, k, srcid, destid, srcid1, destid1, w, del, dist, velocity, ncid, wdType, order, presynapticSize, postsynapticSize, stimsrc localobj presynapticType, postsynapticType, cellTypes, connectivityType, connectivityTypes, synName, nc, edges, m, f, stim
    
    strdef connectivityPath, connectivityName, presynapticPopulation, postsynapticPopulation
    connectivityTypes = $o1
    cellTypes = $o2
    nConnectivityTypes = connectivityTypes.count()
    if (verbose > 0) {
       printf ("nConnectivityTypes = %d\n", nConnectivityTypes)
    }
    
    for k=0, nConnectivityTypes-1 { 
        connectivityType = connectivityTypes.o(k)
        order = connectivityType.getPropertyScalar("order")
        synName = connectivityType.getPropertyScalar("synName")
        wdType = connectivityType.getPropertyScalar("wdType")
        connectivityName = connectivityType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("connectivityName = %s\n", connectivityName)
            printf ("wdType = %d\n", wdType)
        }
        presynapticPopulation = connectivityType.getPropertyString("presynapticPopulation").s
        presynapticType = cellTypes.o(findCellType(cellTypes,presynapticPopulation))
        presynapticSize = presynapticType.getPropertyScalar("numCells")
        presynapticOffset = presynapticType.getPropertyScalar("offset")
        postsynapticPopulation = connectivityType.getPropertyString("postsynapticPopulation").s
        postsynapticType = cellTypes.o(findCellType(cellTypes,postsynapticPopulation))
        postsynapticSize = postsynapticType.getPropertyScalar("numCells")
        postsynapticOffset = postsynapticType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("presynaptic population = %s\n", presynapticPopulation)
            printf ("presynaptic size = %d\n", presynapticSize)
            printf ("postsynaptic population = %s\n", postsynapticPopulation)
            printf ("postsynaptic size = %d\n", postsynapticSize)
        }
        if (strcmp(presynapticType.getPropertyString("templateName").s, "NetStim") == 0) {
            stimsrc = 1
            sprint(cmd, "ncstimlist = nc%slist", presynapticPopulation)
            execute(cmd)
        } else {
            stimsrc = 0
        }
        sprint(connectivityPath, "%s/%s.dat", datasetPath, connectivityName)
        m = new Matrix()
        f = new File(connectivityPath)
        f.ropen()
        m.scanf(f)
        f.close()
        if ((stimsrc == 1) && (wdType == 1)) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                nc = pnm.pc.gid_connect(srcid1, pnm.pc.gid2obj(destid1).syn)
                w = m.x[i][2]
                del = m.x[i][3]
                nc.weight = w
                nc.delay = del
                ncstimlist.append(nc)
		if (makegraph > 0) {
                  edges = new Vector(2)
                  edges.x[0] = srcid1
                  edges.x[1] = destid1
                  conlist.prepend(edges)
		}	
            }
        } else if (wdType == 1) {
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                w = m.x[i][2]
                del = m.x[i][3]
	        ncid = pnm.nc_append(srcid1, destid1, synName, w, del)
                if (verbose > 0) {
                   printf("host %d: connection src = %d dest = %d w = %g del = %g\n", pnm.myid, srcid1, destid1, w, del)
                }
                nc = pnm.nclist.o(ncid)
		if (makegraph > 0) {
                  edges = new Vector(2)
                  edges.x[0] = srcid1
                  edges.x[1] = destid1
                  conlist.prepend(edges)
		}
            }
            m.resize(1,1)
        } else if (wdType == 2) {
            w = connectivityType.getPropertyScalar("standardWeight")
            velocity = connectivityType.getPropertyScalar("standardVelocity")
            for i=0, m.nrow-1 {
                srcid = m.x[i][0]
                destid = m.x[i][1]
                if (order == 0) {
                    // relative numbering of pre/post synaptic cells -- add the respective offsets
                    assert (srcid < presynapticSize, "source cell id is greater than the size of the presynaptic population")
                    assert (destid < postsynapticSize, "destination cell id is greater than the size of the postsynaptic population")
                    srcid1 = srcid + presynapticOffset
                    destid1 = destid + postsynapticOffset
                } else {
                    // absolute numbering of pre/post synaptic cells
                    srcid1 = srcid
                    destid1 = destid
                }
                if (!pnm.gid_exists(destid1)) { continue }
                dist = m.x[i][2] + m.x[i][3]
                del = (dist / velocity) + 1.0
	        ncid = pnm.nc_append(srcid1, destid1, synName, w, del)
                if (verbose > 0) {
                   printf("host %d: connection src = %d dest = %d w = %g del = %g\n", pnm.myid, srcid1, destid1, w, del)
                }
		if (makegraph > 0) {
                  edges = new Vector(2)
                  edges.x[0] = srcid1
                  edges.x[1] = destid1
                  conlist.prepend(edges)
		}
            }
            m.resize(1,1)
        }
    }
}

proc mkgap() { local gid, sgid, dgid, w localobj cell, gj, gjlist
    
    gjlist = $o1
    gid    = $2
    branch = $3
    sec    = $4
    dgid   = $5
    sgid   = $6
    w      = $7
    
    cell = pnm.pc.gid2cell(gid)
    
    cell.dendrites[branch][sec] { 
        gj = new ggap(0.5) 
        pnm.pc.target_var(gj, &gj.vgap, dgid)
        pnm.pc.source_var(&cell.dendrites[branch][sec].v(0.5), sgid)
    }
    
    gjlist.append(gj)
    gj.g = w
    
    if (verbose > 0) {
        printf ("host %d: gap junction: gid = %d branch = %d sec = %d coupling = %g sgid = %d dgid = %d\n", pnm.myid, gid, branch, sec, w, sgid, dgid)
    }
    
}

// creates the gap junctions between cells
proc connectgjs() {local i, k, w, ggid, srcid, destid, srcid1, destid1, srcbranch, destbranch, srcsec, destsec, order, srcSize, destSize localobj srcType, destType, cellTypes, gjType, gjTypes, edges, m, f
    
    strdef gjPath, gjName, srcPopulation, destPopulation
    gjTypes = $o1
    cellTypes = $o2
    nGJTypes = gjTypes.count()
    ggid = 2*ncells
    
    for k=0, nGJTypes-1 { 
        gjType = gjTypes.o(k)
        order  = gjType.getPropertyScalar("order")
        gjName = gjType.getPropertyString("name").s
        if (verbose > 0) {
            printf ("gjName = %s\n", gjName)
        }
        srcPopulation  = gjType.getPropertyString("srcPopulation").s
        destPopulation = gjType.getPropertyString("destPopulation").s
        if (verbose > 0) {
            printf ("src population = %s\n", srcPopulation)
            printf ("dest population = %s\n", destPopulation)
            print "src population index = ", findCellType(cellTypes,srcPopulation)
            print "dest population index = ", findCellType(cellTypes,destPopulation)
        }
        srcType    = cellTypes.o(findCellType(cellTypes,srcPopulation))
        destType   = cellTypes.o(findCellType(cellTypes,destPopulation))
        srcSize    = srcType.getPropertyScalar("numCells")
        destSize   = destType.getPropertyScalar("numCells")
        srcOffset  = srcType.getPropertyScalar("offset")
        destOffset = destType.getPropertyScalar("offset")
        if (verbose > 0) {
            printf ("src size = %d\n", srcSize)
            printf ("dest size = %d\n", destSize)
        }
        sprint(gjPath, "%s/%s.dat", datasetPath, gjName)
        m = new Matrix()
        f = new File(gjPath)
        f.ropen()
        m.scanf(f)
        f.close()
        for i=0, m.nrow-1 {
            srcid = m.x[i][0]
            destid = m.x[i][1]
            srcbranch = m.x[i][2]
            srcsec = m.x[i][3]
            destbranch = m.x[i][4]
            destsec = m.x[i][5]
            w = m.x[i][6]
            if (order == 0) {
                // relative numbering of pre/post synaptic cells -- add the respective offsets
                assert (srcid < srcSize, "source cell id is greater than the size of the src population")
                assert (destid < destSize, "destination cell id is greater than the size of the dest population")
                srcid1 = srcid + srcOffset
                destid1 = destid + destOffset
            } else {
                // absolute numbering of pre/post synaptic cells
                srcid1 = srcid
                destid1 = destid
            }

            
	    if (pnm.gid_exists(srcid1)) { 
		mkgap(gjlist, srcid1, srcbranch, srcsec, ggid+1, ggid, w)
                edges = new Vector(2)
                edges.x[0] = srcid1
                edges.x[1] = destid1
                gjconlist.prepend(edges)
	    }
            
	    if (pnm.gid_exists(destid1)) {
		mkgap(gjlist, destid1, destbranch, destsec, ggid, ggid+1, w)
	    }
            ggid = ggid+2
        }
    }
}


proc mknet() { strdef fname
    startsw()
    mkcells(cellTypes)  // create the cells
    mkcellstime = stopsw()
    printf ("*** Cells created\n")
    startsw()
    connectcells(connectivityTypes,cellTypes)  // connect them together
    connectcellstime = stopsw()
    printf ("*** Synaptic connections created\n")
    startsw()
    connectgjs(gjTypes,cellTypes)  // creates the gap junctions
    connectgjstime = stopsw()
    printf ("*** Gap junctions created\n")
    sprint(fname, "%s/%s_%d.dat", resultsPath, modelName, pnm.myid)
    if (makegraph > 0) {
        graphout(fname,conlist)
    }
}


mknet(ncells)

// Configuration of artificial spiking cells

proc mkstim() { local i, k, nCellTypes, numCells, offset localobj stim, stimulationParameters, cellType, cellTypes
    
    strdef templateName, typeName
    
    datasetPath = $s1
    cellTypes = $o2
    nCellTypes = cellTypes.count()
    
    for k=0, nCellTypes-1 { 
        
        cellType = cellTypes.o(k)
        typeName = cellType.getPropertyString("typeName").s
        templateName = cellType.getPropertyString("templateName").s
        numCells = cellType.getPropertyScalar("numCells")
        offset = cellType.getPropertyScalar("offset")
        
        if (strcmp(templateName, "NetStim") == 0) {
            sprint (datafilePath, "%s/%s.dat", datasetPath, typeName)
            stimulationParameters = new Matrix()
            // Reads the stimulation parameters file and populates the
            // stimulationParameters matrix with the information
            loadStimulationParameters (stimulationParameters, datafilePath)

            for i=0, numCells-1 { 
                if (pnm.gid_exists(offset+i)) {
                    stim = pnm.pc.gid2obj(offset+i)
                    stim.noise  = stimulationParameters.x[i][0]
                    stim.number = stimulationParameters.x[i][1]
                    stim.start  = stimulationParameters.x[i][2]
                }
            }
        }
    }
}

mkstim(datasetPath, cellTypes, ncells)

printf ("*** Stimulus sources initialized\n")

/* Simulation control */


{pnm.pc.setup_transfer()}
{pnm.pc.set_maxstep(10)}

print "dt = ", dt

objref fi
fi = new FInitializeHandler("simstatus()")

stdinit()

printf ("*** Initialization completed\n")

pnm.psolve(tstop)

printf ("*** Simulation completed\n")

/* Write simulation results */

strdef spikeout_fname
sprint(spikeout_fname, "%s/%s_spikeout_%d.dat", resultsPath, modelName, pnm.myid)
spikeout(spikeout_fname,pnm.spikevec,pnm.idvec)

comptime = pnm.pc.step_time
avgcomp  = pnm.pc.allreduce(comptime, 1)/pnm.pc.nhost
maxcomp  = pnm.pc.allreduce(comptime, 2)

if (pnm.myid == 0) {
    printf("Execution time summary for host 0:\n")
    printf("  created cells in %g seconds\n", mkcellstime)
    printf("  connected cells in %g seconds\n", connectcellstime)
    printf("  created gap junctions in %g seconds\n", connectgjstime)
    printf("  ran simulation in %g seconds\n", comptime)
    if (maxcomp > 0) {
        if (pnm.myid == 0) { printf("  load_balance = %g\n", avgcomp/maxcomp) }
    }
}

printf ("*** Simulation results written\n")

pnm.pc.runworker()
pnm.pc.done()

quit()
